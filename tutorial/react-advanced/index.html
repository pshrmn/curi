<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="description" content="undefined">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React Advanced Tutorial | Curi Documentation</title>
    <link href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,400" rel="stylesheet">
    <link href="/static/css/prism.css" rel="stylesheet">
  </head>
  <body>
    <div id="root"><style data-emotion-css="1fhy669">body{font-family:"Zilla Slab",serif;font-weight:300;font-size:24px;line-height:36px;margin:0;box-sizing:border-box;}@media only screen and (min-width:751px){body{font-size:20px;}}*,*:before,*:after{box-sizing:inherit;}h1,h2,h3,h4,h5,h6{font-weight:normal;margin:5px 0;overflow:hidden;text-overflow:ellipsis;}p{margin:5px 0;word-break:break-word;}h1{font-size:1.75em;line-height:1.5em;}h2{font-size:1.5em;line-height:1.2em;}h3{font-size:1.35em;line-height:1.1em;}h4{font-size:1.2em;line-height:1.1em;}h5{font-size:1.1em;line-height:1.1em;}h6{font-size:1em;line-height:1.1em;}table,th,td{border:1px solid #c7c7c7;border-collapse:collapse;}table{margin-bottom:10px;}th{text-align:left;}th,td{padding:10px;}pre[class*="language-"]{margin:0;background:#222233;}:not(pre) > code[class*="language-"]{white-space:nowrap;}</style><style data-emotion-css="137i3vd">.css-137i3vd{display:none;}@media only screen and (min-width:751px){.css-137i3vd{display:block;width:100vw;max-width:100%;background:#222233;padding:0;position:fixed;z-index:1;}.css-137i3vd #home-link{font-size:1.5em;color:#ff9800;}}</style><header class="css-137i3vd e132noc00"><style data-emotion-css="1j4n5ho">.css-1j4n5ho{color:#efefef;}.css-1j4n5ho li{margin-right:20px;padding:0;}.css-1j4n5ho li.base > a{color:#efefef;font-size:1.1em;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:50px;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-bottom:3px solid #222233;padding:0 5px;}.css-1j4n5ho li.base > a:hover{color:#ff9800;}.css-1j4n5ho li.base > a.active{color:#ff9800;border-bottom-color:#ff9800;}.css-1j4n5ho li.base > a.activated{color:#2196f3;border-bottom-color:#2196f3;}.css-1j4n5ho a{-webkit-text-decoration:none;text-decoration:none;}</style><nav class="css-1j4n5ho e132noc02"><style data-emotion-css="192aemx">.css-192aemx{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-flow:row wrap;-ms-flex-flow:row wrap;flex-flow:row wrap;-webkit-align-items:flex-end;-webkit-box-align:flex-end;-ms-flex-align:flex-end;align-items:flex-end;list-style:none;padding:0;margin:0;max-width:100%;}</style><ul class="css-192aemx e132noc01"><li class="base"><a id="home-link" class=" " href="/">Curi</a></li><li class="base"><a data-hide="false" class="group " href="/v2/">API</a></li><li class="base"><a data-hide="false" class="group " href="/guides/">Guides</a></li><li class="base"><a data-hide="false" class="group active" href="/tutorial/">Tutorials</a></li><li class="base"><a data-hide="false" class="group " href="/examples/">Examples</a></li><li class="base"><a href="https://github.com/pshrmn/curi">GitHub</a></li></ul></nav></header><style data-emotion-css="bupcgl">.css-bupcgl{position:fixed;right:15px;bottom:15px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-flow:column-reverse;-ms-flex-flow:column-reverse;flex-flow:column-reverse;z-index:9999;}</style><div class="css-bupcgl e18ecyrg1"><style data-emotion-css="8wphu1">.css-8wphu1{width:75px;height:75px;border-radius:40px;border:0;margin-top:10px;font-size:1em;font-family:"Zilla Slab",serif;background:#2196f3;}@media only screen and (min-width:751px){.css-8wphu1{display:none;}}</style><button type="button" class="toggler css-8wphu1 e1105ass0">Menu</button><style data-emotion-css="4pglcz">.css-4pglcz{width:75px;height:75px;border-radius:40px;border:0;margin-top:10px;font-size:1em;font-family:"Zilla Slab",serif;background:#c7c7c7;}@media only screen and (min-width:751px){.css-4pglcz{display:none;}}.css-4pglcz.active{background:#81c784;}</style><button hidden="" class="false active main css-4pglcz e1105ass1">Main</button><button hidden="" class="false false page css-4pglcz e1105ass1">Page</button></div><style data-emotion-css="b9kg8f">.css-b9kg8f{display:none;position:fixed;overflow-y:scroll;width:100vw;height:100vh;background:#efefef;z-index:999;padding:15px;}.css-b9kg8f.visible{display:block;}.css-b9kg8f ul{margin:3px 0;padding-left:0px;list-style:none;}.css-b9kg8f li{margin:3px 0;}.css-b9kg8f a{-webkit-text-decoration:none;text-decoration:none;display:inline-block;color:#222233;}.css-b9kg8f h3{border-bottom:1px solid #333;}.css-b9kg8f .active{font-weight:bold;}.css-b9kg8f .children{display:none;background:#efefef;padding:10px;}.css-b9kg8f .children.visible{display:block;position:fixed;top:0;bottom:0;left:0;right:0;overflow-y:scroll;}@media only screen and (min-width:751px){.css-b9kg8f{display:none;}.css-b9kg8f.visible{display:none;}}</style><div hidden="" class=" css-b9kg8f e18ecyrg0"><nav></nav></div><style data-emotion-css="89bx5e">.css-89bx5e{width:100vw;max-width:100%;padding:10px 10px 0;margin-bottom:20px;}.css-89bx5e a{color:#222233;}@media only screen and (min-width:751px){.css-89bx5e{padding:50px 0 0;margin-bottom:0;}}</style><main tabindex="-1" style="outline:none" class="css-89bx5e e1fl12nk0"><style data-emotion-css="csv88t">.css-csv88t{position:relative;}@media only screen and (min-width:751px){.css-csv88t{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-flow:row nowrap;-ms-flex-flow:row nowrap;flex-flow:row nowrap;}}@media only screen and (min-width:751px){.css-csv88t{max-width:100vw;}}</style><div class="css-csv88t e1hcridg0"><style data-emotion-css="q1fc1d">@media only screen and (min-width:751px){.css-q1fc1d{margin-left:275px;}}</style><div class="css-q1fc1d e1hcridg1"><style data-emotion-css="10r1tdh">.css-10r1tdh{margin-top:15px;}.css-10r1tdh p{margin:0 0 25px;font-size:0.8em;}.css-10r1tdh .aside{padding:5px 10px;border-left:2px solid $border-green;background:#e8f5e9;margin-top:15px;}.css-10r1tdh .aside .inline-code{background:#b7dab9 !important;}@media only screen and (min-width:751px){.css-10r1tdh{max-width:751px;}.css-10r1tdh p{font-size:1em;}.css-10r1tdh.centered{margin:0 auto;}}</style><div class="section css-10r1tdh"><h1>React Advanced Tutorial</h1><p>In this tutorial, we will be expanding on the website built in the<!-- --> <a href="/tutorial/react-basics/">React basics tutorial</a>. We will take advantage of Curi&#x27;s async features to add code splitting and data preloading to the application.</p><style data-emotion-css="5p5dk0">.css-5p5dk0{border:1px solid #2196f3;padding:10px;margin:5px 0;background:#deeffe;}.css-5p5dk0 p{margin:0;}.css-5p5dk0 .inline-code{background:#64b5f6 !important;}</style><div class="css-5p5dk0 eum1gdz0"><p><strong>We will be doing the following:</strong></p><ul><li>Add code splitting to routes.</li><li>Preload route data with asynchronous navigation.</li></ul></div></div><style data-emotion-css="cwwtwq">.css-cwwtwq{margin-top:15px;}.css-cwwtwq p{margin:0 0 25px;font-size:0.8em;}.css-cwwtwq .aside{padding:5px 10px;border-left:2px solid $border-green;background:#e8f5e9;margin-top:15px;}.css-cwwtwq .aside .inline-code{background:#b7dab9 !important;}@media only screen and (min-width:751px){.css-cwwtwq{max-width:751px;}.css-cwwtwq p{font-size:1em;}.css-cwwtwq.centered{margin:0 auto;}}.css-cwwtwq .header-link{-webkit-text-decoration:none;text-decoration:none;}.css-cwwtwq .header-link::after{content:"#";color:#333;margin-left:5px;}@media only screen and (min-width:751px){.css-cwwtwq:before{content:"";display:block;margin-top:-50px;height:50px;visibility:hidden;}.css-cwwtwq p{font-size:1em;}.css-cwwtwq .header-link::after{display:none;}.css-cwwtwq .header-link:hover::after{display:inline-block;}}</style><div class="section css-cwwtwq" id="demo"><h2><a class="header-link" href="#demo">Demo</a></h2><p>You can run a demo of the site we are building with CodeSandbox.</p><style data-emotion-css="7wx121">.css-7wx121 p{font-style:italic;text-align:center;margin:0;}@media only screen and (min-width:751px){.css-7wx121{max-width:80vw;margin:0 auto;}}</style><div class="css-7wx121 egdjct20"><iframe src="https://codesandbox.io/embed/github/curijs/react-advanced-tutorial/tree/master/?view=split" width="100%" height="600px" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin" tabindex="-1"></iframe><p>Use the three buttons at the top of the Sandbox to toggle view modes. Clicking the menu button in the top left corner opens a menu to switch between files.</p></div></div><div class="section css-cwwtwq" id="setup"><h2><a class="header-link" href="#setup">Setup</a></h2><p>If you did not complete the React basics tutorial, you should either clone its<!-- --> <a href="https://github.com/curijs/react-basic-tutorial/">repo</a> or fork its<!-- --> <a href="https://codesandbox.io/s/github/curijs/react-basic-tutorial/tree/master/">sandbox</a>.</p><p>If you are cloning the repo, you should also install its dependencies and then start the development server.</p><style data-emotion-css="xg7t84">.css-xg7t84{width:100%;margin:0 0 25px;font-size:0.8em;}.css-xg7t84 pre{white-space:pre-wrap;height:100%;vertical-align:top;}@media only screen and (min-width:751px){.css-xg7t84{font-size:1em;}.css-xg7t84 code{min-width:200px;white-space:pre-wrap;}}</style><div class="css-xg7t84 e12etsbl0"><pre><code class="language-bash">git clone https://github.com/curijs/react-basic-tutorial react-advanced-tutorial
cd react-advanced-tutorial
npm install
npm run start</code></pre></div></div><div class="section css-cwwtwq" id="async"><h2><a class="header-link" href="#async">Asynchronous Routes</a></h2><p>Curi lets you attach async functions to a route through its<!-- --> <style data-emotion-css="jo5c25">.css-jo5c25{padding:0.1em;border-radius:0.3em;white-space:normal;background:#fff;color:#222233;text-shadow:none;white-space:wrap;}.css-jo5c25 .token{color:#222233;}</style><code class="inline-code css-jo5c25 eutm4hs0">resolve</code> function. When that route matches, a response will not be emitted until the <code class="inline-code css-jo5c25 eutm4hs0">resolve</code> has resolved.</p><p><code class="inline-code css-jo5c25 eutm4hs0">resolve</code> be passed an object of the matched route properties, which you may use to specify what data to load.</p><p>The results of the async functions will be available in a route&#x27;s<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">respond</code> function through the <code class="inline-code css-jo5c25 eutm4hs0">resolved</code> object. Each result will be stored in the object using the async function&#x27;s name.</p><p>If any of the async functions throws an uncaught error, that error will be available in the <code class="inline-code css-jo5c25 eutm4hs0">respond</code> function through the<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">error</code> property. That said, it is preferable for you to catch and handle the errors yourself.</p><div class="css-xg7t84 e12etsbl0"><pre><code class="language-javascript">{
  name: &quot;A Route&quot;,
  path: &quot;route/:id&quot;,
  resolve({ params }) {
    const body = import(&quot;./components/SomeComponent&quot;)
      .then(preferDefault);
    const data = fetch(`/api/data/${params.id}`);
    return Promise.all([ component, data ]);
  },
  respond({ resolved, error }) {
    if (error) {
      // handle an uncaught error
    }
    const [body, data] = resolved;
    return { body, data };
  }
}</code></pre></div><style data-emotion-css="o0tph9">.css-o0tph9{padding:10px 5px;margin:5px 0;border:1px solid #c7c7c7;background:#eeeeee;}.css-o0tph9 p:last-child{margin-bottom:0;}.aside .css-o0tph9{background:#fff;}.css-o0tph9 .inline-code{background:#fff !important;}</style><div class="css-o0tph9 e1bjkffy0"><strong>Note:</strong> <p>These async functions are called every time a route matches. If you have functions that should re-use the results from previous calls, you will probably want to implement some caching. Curi provides a<!-- --> <a href="/v2/@curi/helpers/#once"><code class="inline-code css-jo5c25 eutm4hs0">once</code></a> <!-- -->function for simple caching, but leaves more advanced caching solutions to the user.</p></div><p>Curi uses Promises to manage async code, so async functions should return Promises. <code class="inline-code css-jo5c25 eutm4hs0">Promise.resolve</code> can be used to wrap a return value in a Promise.</p><div class="css-xg7t84 e12etsbl0"><pre><code class="language-javascript">import { preferDefault } from &quot;@curi/helpers&quot;;

const routes = prepareRoutes([
  {
    name: &quot;A Route&quot;,
    path: &quot;route/:id&quot;,
    resolve({ params }) {
      const body = import(&quot;./components/SomeComponent&quot;)
        .then(preferDefault);
      const data = fetch(`/api/data/${params.id}`);
      return Promise.all([ component, data ]);
    },
    respond({ resolved, error }) {
      if (error) {
        // handle an uncaught error
      }
      const [body, data] = resolved;
      return { body, data };
    }
  }
]);</code></pre></div><div class="aside css-cwwtwq" id="initial-render"><h3><a class="header-link" href="#initial-render">Initial Render</a></h3><p>There is one caveat to async routes: we cannot safely render the application immediately on load because the initial response might not be ready yet.</p><p>Curi does not emit a response object to its observers until it is ready. If the initial route that matches is asynchronous, then there is a delay between when the application is ready to render and when there is a response to render.</p><p>If you attempt to render immediately after creating a router and the initial response is still being created, the <code class="inline-code css-jo5c25 eutm4hs0">response</code> <!-- -->that will be passed to the <code class="inline-code css-jo5c25 eutm4hs0">Router</code>&#x27;s <code class="inline-code css-jo5c25 eutm4hs0">children</code> <!-- -->will be <code class="inline-code css-jo5c25 eutm4hs0">undefined</code>.</p><p>There are a few possible ways to handle this situation.</p><p>The first is to delay rendering by placing your<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">ReactDOM.render</code> call inside of a <code class="inline-code css-jo5c25 eutm4hs0">router.once</code> <!-- -->callback. This will guarantee that the render isn&#x27;t called until the first response is ready.</p><div class="css-xg7t84 e12etsbl0"><pre><code class="language-javascript">// delay rendering
router.once(() =&gt; {
  ReactDOM.render((
    &lt;Router&gt;
      &lt;App /&gt;
    &lt;/Router&gt;
  ), holder);
});
</code></pre></div><p>Alternatively, you can update the root <code class="inline-code css-jo5c25 eutm4hs0">App</code> component to detect when the <code class="inline-code css-jo5c25 eutm4hs0">response</code> is <code class="inline-code css-jo5c25 eutm4hs0">undefined</code> and render a loading message.</p><div class="css-xg7t84 e12etsbl0"><pre><code class="language-javascript">// render fallback when response is null
function App() {
  const { response } = useResponse();
  if (response === undefined) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }
  const { body:Body } = response;
  return &lt;Body response={response} /&gt;;
}</code></pre></div><p>Which approach is best will depend on the specifics of an application. If there are routes that will take a long time for the initial load, you will probably want to render something while they load. For async code with short loading times, a blank screen might be more acceptable.</p></div><p>For more information on async route properties, please refer to the<!-- --> <a href="/guides/routes/">routes guide</a>.</p></div><div class="section css-cwwtwq" id="code-splitting-routes"><h2><a class="header-link" href="#code-splitting-routes">Code Splitting in Routes</a></h2><p>Currently, the <code class="inline-code css-jo5c25 eutm4hs0">routes.js</code> module imports all of the route modules at the top of the file. This results in a single bundle of all of a website&#x27;s code. This can be improved by adding code splitting to an application, which will result in more, but smaller, bundles.</p><div class="aside css-cwwtwq" id="code-splitting"><h3><a class="header-link" href="#code-splitting">Code Splitting</a></h3><p>Code splitting works by &quot;dynamically&quot; importing modules using the<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">import</code> function. When bundlers like Webpack see<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">import</code> functions, they know to create a separate bundle for that module (and that module&#x27;s imports, etc.).</p><p>You can set a chunk&#x27;s name using the<!-- --> <a href="https://webpack.js.org/api/module-methods/#magic-comments"><code class="inline-code css-jo5c25 eutm4hs0">webpackChunkName</code></a> <!-- -->magic comment with an <code class="inline-code css-jo5c25 eutm4hs0">import</code> call.</p><p>Create React App&#x27;s default configuration is already setup to support code splitting, but if you were creating your own Webpack configuration, you would need to use<!-- --> <a href="https://webpack.js.org/configuration/output/#output-chunkfilename"><code class="inline-code css-jo5c25 eutm4hs0">output.chunkFilename</code></a> <!-- -->to support code splitting.</p><div class="css-xg7t84 e12etsbl0"><pre><code class="language-javascript">// this creates a &quot;Test&quot; bundle
import(/* webpackChunkName: &quot;Test&quot; */ &quot;./components/Test.js&quot;)</code></pre></div><p><code class="inline-code css-jo5c25 eutm4hs0">import</code> returns a module object, so if you want to access a module&#x27;s default export, you can use a <code class="inline-code css-jo5c25 eutm4hs0">then</code> function to get that value.</p><div class="css-xg7t84 e12etsbl0"><pre><code class="language-javascript">import(&quot;some-module.js&quot;)
  .then(module =&gt; module.default)</code></pre></div></div><p>Currently <code class="inline-code css-jo5c25 eutm4hs0">respond</code> function returns an object whose<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">body</code> property is a module imported at the top of the file. In order to add code splitting to routes, we can add a<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">resolve</code> function that imports the module.</p><p>The <code class="inline-code css-jo5c25 eutm4hs0">@curi/helpers</code> package provides a<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">preferDefault</code> function. This function will return an imported module&#x27;s default property if it exists, and returns the entire module if it doesn&#x27;t have a default property.</p><div class="css-xg7t84 e12etsbl0"><pre><code class="language-javascript">import { preferDefault } from &quot;@curi/helpers&quot;;

const routes = prepareRoutes([
  {
    name: &quot;Test&quot;,
    path: &quot;test&quot;,
    resolve() {
      return import(
        /* webpackChunkName: &quot;Test&quot; */ &quot;./components/Test.js&quot;
      ).then(preferDefault);
    }
  }
]);</code></pre></div><p>When a module fails to load, the error will be passed to the<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">respond</code> function through the <code class="inline-code css-jo5c25 eutm4hs0">error</code> property. We won&#x27;t be incorporating this into the application here, but in a real application you probably want to have a fallback component to display an error message (especially if you have an offline mode with service workers).</p><div class="css-xg7t84 e12etsbl0"><pre><code class="language-javascript">import displayLoadError from &quot;./components/LoadError&quot;;

const routes = prepareRoutes([
  {
    name: &quot;One&quot;,
    path: &quot;one&quot;,
    resolve() {
      return import(&quot;./components/One.js&quot;)
        .then(preferDefault)
        .catch(err =&gt; displayLoadError(err);
    },
    respond({ resolved }) {
      return {
        body: resolved
      };
    }
  }
]);</code></pre></div><p>We can now update the <code class="inline-code css-jo5c25 eutm4hs0">routes.js</code> module to remove the imports at the top of the file and use <code class="inline-code css-jo5c25 eutm4hs0">import</code> to import the route components. We will use <code class="inline-code css-jo5c25 eutm4hs0">preferDefault</code> to only resolve the component instead of the entire module object.</p><p>The <code class="inline-code css-jo5c25 eutm4hs0">respond</code> functions should also be updated to set the return object&#x27;s <code class="inline-code css-jo5c25 eutm4hs0">body</code> property to <code class="inline-code css-jo5c25 eutm4hs0">resolved.body</code> <!-- -->instead of the import at the top of the file.</p><div class="css-xg7t84 e12etsbl0"><pre data-line="3,10-16,21-27,32-38,43-49"><code class="language-javascript">// src/routes.js
import { prepareRoutes } from &quot;@curi/router&quot;;
import { preferDefault } from &quot;@curi/helpers&quot;;

export default prepareRoutes([
  {
    name: &quot;Home&quot;,
    path: &quot;&quot;,
    resolve() {
      return import(&quot;./components/Home&quot;)
        .then(preferDefault);
    },
    respond({ resolved }) {
      return { body: resolved };
    }
  },
  {
    name: &quot;Book&quot;,
    path: &quot;book/:id&quot;,
    resolve() {
      return import(&quot;./components/Book&quot;)
        .then(preferDefault);
    },
    respond({ resolved }) {
      return { body: resolved };
    }
  },
  {
    name: &quot;Checkout&quot;,
    path: &quot;checkout&quot;,
    resolve() {
      return import(&quot;./components/Checkout&quot;)
        .then(preferDefault);
    },
    respond({ resolved }) {
      return { body: resolved };
    }
  },
  {
    name: &quot;Catch All&quot;,
    path: &quot;(.*)&quot;,
    resolve() {
      return import(&quot;./components/NotFound&quot;)
        .then(preferDefault);
    },
    respond({ resolved }) {
      return { body: resolved };
    }
  }
]);</code></pre></div><p>For this tutorial, we will use <code class="inline-code css-jo5c25 eutm4hs0">router.once</code> to delay the initial render while we wait for the initial response. We should update the <code class="inline-code css-jo5c25 eutm4hs0">index.js</code> module to do this.</p><div class="css-xg7t84 e12etsbl0"><pre data-line="22-28"><code class="language-javascript">// src/index.js
import React from &#x27;react&#x27;;
import ReactDOM from &#x27;react-dom&#x27;;
import { createRouter, announce } from &quot;@curi/router&quot;;
import { browser } from &#x27;@hickory/browser&#x27;;
import { createRouterComponent } from &#x27;@curi/react-dom&#x27;;

import routes from &#x27;./routes&#x27;;
import &#x27;./index.css&#x27;;
import NavMenu from &#x27;./components/NavMenu&#x27;;
import registerServiceWorker from &#x27;./registerServiceWorker&#x27;;

const router = createRouter(browser, routes, {
  sideEffects: [
    announce(({ response }) =&gt; {
      return `Navigated to ${response.location.pathname}`;
    })
  ]
});
const Router = createRouterComponent(router);

router.once(() =&gt; {
  ReactDOM.render((
    &lt;Router&gt;
      &lt;App /&gt;
    &lt;/Router&gt;
  ), document.getElementById(&#x27;root&#x27;));
});
registerServiceWorker();</code></pre></div><p>With those changes, Webpack will now split the application into multiple bundles. The initial render will be delayed until after the code split bundle for the first route has been loaded.</p></div><div class="section css-cwwtwq" id="preloading-data"><h2><a class="header-link" href="#preloading-data">Preloading Data</a></h2><p>Preloading data lets you delay navigation until after the data for a route has loaded. This can save you from having to render a partial page with spinners if the data takes a while to load.</p><p>While the data is loading, the user will be able to continue interacting with the current page. This means that the user can also start a new navigation while the current navigation is running. When this happens, Curi knows to to cancel the previous navigation and perform the new navigation instead.</p><p>We have two routes that need to load data: <code class="inline-code css-jo5c25 eutm4hs0">Home</code> and<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">Book</code>. The <code class="inline-code css-jo5c25 eutm4hs0">Home</code> route will load the known books, while the <code class="inline-code css-jo5c25 eutm4hs0">Book</code> route will load data about a specific book.</p><p>Currently the data for both of these routes is imported in their components. In a real site you would most likely make API calls to a REST or GraphQL endpoint, but here we will simulate this with a fake API.</p><div class="section css-cwwtwq" id="fake-api"><h3><a class="header-link" href="#fake-api">The Fake API</a></h3><p>The fake API will simulate asynchronous calls to the server by returning Promises, similarly to the<!-- --> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>.</p><p>First, we will create an <code class="inline-code css-jo5c25 eutm4hs0">api.js</code> module that exports the fake API functions.</p><div class="css-xg7t84 e12etsbl0"><pre><code class="language-bash">touch src/api.js</code></pre></div><p>In the API module, we will import the <code class="inline-code css-jo5c25 eutm4hs0">books.js</code> data.</p><p>We need to write two functions. The first returns a list of all books and the second returns the data for a specific book. For both, we can use <code class="inline-code css-jo5c25 eutm4hs0">Promise.resolve</code> to return a Promise, even though we don&#x27;t really have any asynchronous code being run.</p><div class="css-xg7t84 e12etsbl0"><pre><code class="language-javascript">// src/api.js
import books from &quot;./books&quot;;

export const BOOKS = () =&gt; Promise.resolve(books);

export const BOOK = id =&gt; Promise.resolve(
  const intID = parseInt(id, 10);
  books.find(b =&gt; b.id === intID)
);</code></pre></div></div><p>When the router is created, it can take a third argument, which is an options object. One of the properties of this object is<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">external</code>, which is used to pass in external values that will be accessible in a route&#x27;s <code class="inline-code css-jo5c25 eutm4hs0">resolve</code> and<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">respond</code> functions. This is particularly useful for data that is initialized at runtime, like an Apollo store, but we will also use it here.</p><div class="css-xg7t84 e12etsbl0"><pre data-line="11,20-22"><code class="language-javascript">// src/index.js
import React from &#x27;react&#x27;;
import ReactDOM from &#x27;react-dom&#x27;;
import { createRouter } from &quot;@curi/router&quot;;
import { browser } from &#x27;@hickory/browser&#x27;;
import { createRouterComponent } from &#x27;@curi/react-dom&#x27;;

import routes from &#x27;./routes&#x27;;
import &#x27;./index.css&#x27;;
import NavMenu from &#x27;./components/NavMenu&#x27;;
import * as bookAPI from &quot;./api&quot;;
import registerServiceWorker from &#x27;./registerServiceWorker&#x27;;

const router = createRouter(browser, routes, {
  sideEffects: [
    announce(({ response }) =&gt; {
      return `Navigated to ${response.location.pathname}`;
    })
  ],
  external: {
    bookAPI
  }
});
const Router = createRouterComponent(router);

router.once(() =&gt; {
  ReactDOM.render((
    &lt;Router&gt;
      &lt;App /&gt;
    &lt;/Router&gt;
  ), document.getElementById(&#x27;root&#x27;));
});
registerServiceWorker();</code></pre></div><p>What do we want to do with the data loaded from the API calls? Along with the <code class="inline-code css-jo5c25 eutm4hs0">body</code> property, another valid return property for<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">respond</code> functions is <code class="inline-code css-jo5c25 eutm4hs0">data</code>. This is a convenient way to attach any data to a response, which we can read from while rendering.</p><p>The <code class="inline-code css-jo5c25 eutm4hs0">Home</code> route already has an asynchronous action: importing the <code class="inline-code css-jo5c25 eutm4hs0">body</code> component. We will name the async call to load the books data <code class="inline-code css-jo5c25 eutm4hs0">&quot;books&quot;</code>.</p><p>The <code class="inline-code css-jo5c25 eutm4hs0">Book</code> route&#x27;s <code class="inline-code css-jo5c25 eutm4hs0">respond</code> function also needs to be updated to attach the books data (<code class="inline-code css-jo5c25 eutm4hs0">resolved.books</code>) to the response.</p><p>The <code class="inline-code css-jo5c25 eutm4hs0">book</code> API call expects to be given the <code class="inline-code css-jo5c25 eutm4hs0">id</code> <!-- -->number of the book it should return data for. We can grab the correct param (<code class="inline-code css-jo5c25 eutm4hs0">id</code>) from the <code class="inline-code css-jo5c25 eutm4hs0">params</code> property. However, when params are parsed, they are stored as strings. To convert it to a number, we can use the route&#x27;s <code class="inline-code css-jo5c25 eutm4hs0">params</code> property to tell Curi how to parse the <code class="inline-code css-jo5c25 eutm4hs0">id</code>. By giving it a function that calls<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">parseInt</code> on the provided value, <code class="inline-code css-jo5c25 eutm4hs0">params.id</code> will be a number instead of a string.</p><div class="css-xg7t84 e12etsbl0"><pre data-line="10,13,17-21,27,30,34-38"><code class="language-javascript">// src/routes.js
import { prepareRoutes } from &quot;@curi/router&quot;;
import { preferDefault } from &quot;@curi/helpers&quot;;

export default prepareRoutes([
  {
    name: &quot;Home&quot;,
    path: &quot;&quot;,
    resolve(_, external) {
      const body = import(&quot;./components/Home&quot;)
        .then(preferDefault);
      const books = external.bookAPI.BOOKS();
      return Promise.all([body, books]);
    },
    respond({ resolved }) {
      const [body, books] = resolved;
      return {
        body,
        data: { books }
      };
    }
  },
  {
    name: &quot;Book&quot;,
    path: &quot;book/:id&quot;,
    resolve({ params }, external) {
      const body = import(&quot;./components/Book&quot;)
        .then(preferDefault);
      const book = external.bookAPI.BOOK(params.id);
      return Promise.all([body, books]);
    },
    respond({ resolved }) {
      const [body, book] = resolved;
      return {
        body,
        data: { book }
      };
    }
  },
  {
    name: &quot;Checkout&quot;,
    path: &quot;checkout&quot;,
    resolve() {
      return import(&quot;./components/Checkout&quot;)
        .then(preferDefault);
    },
    respond({ resolved }) {
      return { body: resolved };
    }
  },
  {
    name: &quot;Catch All&quot;,
    path: &quot;(.*)&quot;,
    resolve() {
      return import(&quot;./components/NotFound&quot;)
        .then(preferDefault);
    },
    respond({ resolved }) {
      return { body: resolved };
    }
  }
]);</code></pre></div><p>With the data attached to our responses, we can remove the data imports from the components and just read from the response.</p><p>In the <code class="inline-code css-jo5c25 eutm4hs0">Home</code> component&#x27;s module, we can remove the<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">books.js</code> import and grab the response from the component&#x27;s props. The books data can be access as <code class="inline-code css-jo5c25 eutm4hs0">response.data.books</code>.</p><div class="css-xg7t84 e12etsbl0"><pre data-line="5,9"><code class="language-jsx">// src/components/Home.js
import React from &#x27;react&#x27;;
import { Link } from &#x27;@curi/react-dom&#x27;;

export default function Home({ response }) {
  return (
    &lt;div&gt;
      &lt;ul&gt;
        {response.data.books.map(book =&gt; (
          &lt;li key={book.id}&gt;
            &lt;Link name=&quot;Book&quot; params={{ id: book.id }} &gt;
              {book.title} by {book.author}
            &lt;/Link&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</code></pre></div><p>Likewise, we can remove the <code class="inline-code css-jo5c25 eutm4hs0">books.js</code> import from the<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">Book</code> component&#x27;s module and grab the book data from<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">response.data</code> instead of searching for it in the books array.</p><div class="css-xg7t84 e12etsbl0"><pre data-line="9"><code class="language-jsx">// src/components/Book.js
import React from &#x27;react&#x27;;
import { useRouter } from &#x27;@curi/react-dom&#x27;;

import cart from &#x27;../cart&#x27;;

export default function Book({ response }) {
  const router = useRouter();
  const { book } = response.data;
  if (!book) {
    return &lt;div&gt;The requested book could not be found&lt;/div&gt;;
  }
  return (
    &lt;div&gt;
      &lt;h1&gt;{book.title}&lt;/h1&gt;
      &lt;h2&gt;by {book.author}&lt;/h2&gt;
      &lt;p&gt;Published in {book.published}&lt;/p&gt;
      &lt;p&gt;{book.pages} pages&lt;/p&gt;
      &lt;button
        type=&quot;button&quot;
        onClick={() =&gt; {
          cart.add(book, 1);
          const url = router.url({ name: &quot;Checkout&quot; });
          router.navigate({ url });
        }}
      &gt;
        Add to Cart
      &lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre></div></div><div class="section css-cwwtwq" id="loading"><h2><a class="header-link" href="#loading">Visualizing Loading</a></h2><p>At this point, we have the same functionality as the basic tutorial, but we have added async data loading. The bundle importing has real loading times, but the fake API calls resolve immediately, which doesn&#x27;t necessarily reflect real world performance.</p><p>We can update the fake API to delay resolving so that we can take a look at some of the <code class="inline-code css-jo5c25 eutm4hs0">@curi/react-dom</code> components that are navigation-aware. The implementation here isn&#x27;t important, so you can just copy+paste the code. The only thing to know is that the<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">BOOKS</code> function has a one second delay and the<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">BOOK</code> function has a 2.5 second delay the first time a book is requested (and responds instantly on subsequent calls).</p><div class="css-xg7t84 e12etsbl0"><pre><code class="language-javascript">// src/api.js
import books from &quot;./books&quot;;

export const BOOKS = () =&gt; new Promise(resolve =&gt; {
  // artificial delay
  setTimeout(() =&gt; {
    resolve(books);
  }, 1000);
});

const BOOK_CACHE = {};
export const BOOK = id =&gt; new Promise(resolve =&gt; {
  if (BOOK_CACHE[id]) {
    resolve(BOOK_CACHE[id]);
    return;
  }
  const intID = parseInt(id, 10);
  // artificial delay on first call
  setTimeout(() =&gt; {
    const book = books.find(b =&gt; b.id === id);
    BOOK_CACHE[id] = book;
    resolve(book);
  }, 2500);
});</code></pre></div><div class="section css-cwwtwq" id="link-navigating"><h3><a class="header-link" href="#link-navigating">Link is navigating?</a></h3><p>The <code class="inline-code css-jo5c25 eutm4hs0">Link</code> component has a sibling component called<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">AsyncLink</code>, can takes a render-invoked function as its<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">children</code> prop. The function is called with a<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">navigating</code> boolean that indicates whether the router is currently navigating to that link. This is useful for when you know that there is a long (multiple seconds) delay between when the user clicks the link and when the navigation will occur.</p><p>We can replace the <code class="inline-code css-jo5c25 eutm4hs0">Link</code>s in the <code class="inline-code css-jo5c25 eutm4hs0">Home</code> component with <code class="inline-code css-jo5c25 eutm4hs0">AsyncLink</code>s and use render-invoked functions to display a loading spinner while we wait for the book data to load.</p><div class="css-xg7t84 e12etsbl0"><pre><code class="language-jsx">import { AsyncLink } from &quot;@curi/react-dom&quot;;

&lt;AsyncLink name=&quot;Book&quot; params={{ id: 1 }}&gt;
  {navigating =&gt; (
    &lt;React.Fragment&gt;
      Book 1
      {navigating ? &lt;Spinner /&gt; : null}
    &lt;/React.Fragment&gt;
  )}
&lt;/AsyncLink&gt;</code></pre></div><p>We will use the<!-- --> <a href="https://github.com/KyleAMathews/react-spinkit"><code class="inline-code css-jo5c25 eutm4hs0">react-spinkit</code></a> <!-- -->package, which provides a variety of spinner components.</p><div class="css-xg7t84 e12etsbl0"><pre><code class="language-bash">npm install react-spinkit</code></pre></div><p>In the <code class="inline-code css-jo5c25 eutm4hs0">Home</code> component&#x27;s module, we need to import the<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">Spinner</code> component. The <code class="inline-code css-jo5c25 eutm4hs0">Link</code> needs to be swapped from a React element to a render-invoked function. We wrap the contents in a <code class="inline-code css-jo5c25 eutm4hs0">React.Fragment</code> to avoid unnecessary DOM elements. In the function, we render a <code class="inline-code css-jo5c25 eutm4hs0">Spinner</code> when the<!-- --> <code class="inline-code css-jo5c25 eutm4hs0">Link</code> is navigating and <code class="inline-code css-jo5c25 eutm4hs0">null</code> when it is not.</p><div class="css-o0tph9 e1bjkffy0"><strong>Note:</strong> <p><code class="inline-code css-jo5c25 eutm4hs0">react-spinkit</code> is highly customizable, but we are sticking with the defaults here. <code class="inline-code css-jo5c25 eutm4hs0">react-spinkit</code> has a default one second render delay, which is why the spinner does not display immediately.</p></div><div class="css-xg7t84 e12etsbl0"><pre data-line="3-4,12-19"><code class="language-jsx">// src/components/Home.js
import React from &#x27;react&#x27;;
import { AsyncLink } from &#x27;@curi/react-dom&#x27;;
import Spinner from &quot;react-spinkit&quot;;

export default function Home({ response }) {
  return (
    &lt;div&gt;
      &lt;ul&gt;
        {response.data.books.map(book =&gt; (
          &lt;li key={book.id}&gt;
            &lt;AsyncLink name=&quot;Book&quot; params={{ id: book.id }} &gt;
              {navigating =&gt; (
                &lt;React.Fragment&gt;
                  {book.title} by {book.author}
                  {navigating ? &lt;Spinner /&gt; : null}
                &lt;/React.Fragment&gt;
              )}
            &lt;/AsyncLink&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}</code></pre></div></div></div><div class="section css-cwwtwq" id="caveats"><h2><a class="header-link" href="#caveats">Async Caveats</a></h2><p>Adding asynchronous loading to an application can help reduce initial load size and speed up user interactions, however it also has some issues that you will need to consider.</p><p>The biggest consideration is that there is nothing the frontend can do to get the data for the initial render faster. Your application&#x27;s frontend can only fetch data as it discovers it needs it. If you are performing server-side rendering, you may want to load the initial data on the server and inject it into the page&#x27;s HTML output. The implementation details for this vary greatly and are more related to how you store data (e.g.<!-- --> <a href="https://redux.js.org/recipes/server-rendering#the-server-side">with redux</a>).</p><p>Another consideration is whether or not you want to &quot;hoist&quot; data requirements. Curi&#x27;s async functionality relies on you knowing all of the data requirements for a route, but you might prefer to keep the data associated with individual components. React Suspense will help with this (and Curi will support it once it releases), but this is still a ways out. At the very least, I would recommend using Curi for code splitting routes. Whether your should hoist other data requirements is something that should be determined on a case-by-case basis.</p></div></div><style data-emotion-css="64fwtw">.css-64fwtw{display:none;}@media only screen and (min-width:751px){.css-64fwtw{background:#efefef;display:block;position:fixed;top:50px;bottom:0px;overflow:auto;-webkit-flex:0 0;-ms-flex:0 0;flex:0 0;-webkit-order:-1;-ms-flex-order:-1;order:-1;padding:25px;margin-right:25px;}}</style><div class="css-64fwtw e1hcridg2"><style data-emotion-css="1eimyfs">.css-1eimyfs{width:200px;}.css-1eimyfs p{margin:0;}.css-1eimyfs a{-webkit-text-decoration:none;text-decoration:none;display:block;}.css-1eimyfs ol{padding-left:0;margin-top:0;list-style-type:none;}.css-1eimyfs ol ol{padding-left:15px;font-size:0.9em;}</style><div class="css-1eimyfs e1evhjzy0"><ol><li><a href="#demo">Demo</a></li><li><a href="#setup">Setup</a></li><li><a href="#async">Asynchronous Routes</a><ol><li><a href="#initial-render">Initial Render</a></li></ol></li><li><a href="#code-splitting-routes">Code Splitting in Routes</a><ol><li><a href="#code-splitting">Code Splitting</a></li></ol></li><li><a href="#preloading-data">Preloading Data</a><ol><li><a href="#fake-api">The Fake API</a></li></ol></li><li><a href="#loading">Visualizing Loading</a><ol><li><a href="#link-navigating">Link is navigating?</a></li></ol></li><li><a href="#caveats">Async Caveats</a></li></ol></div></div></div></main></div>
    <script src="https://unpkg.com/react@16.8.6/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16.8.6/umd/react-dom.production.min.js"></script>
    <script src="/static/js/prism.js"></script>
    <script src="/static/js/bundle.js"></script>
  </body>
</html>
