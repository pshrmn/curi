(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{81:function(e,t,n){"use strict";n.r(t);var a=n(0),l=n.n(a),r=n(20),o=n(3),s={title:"history",hash:"history"},u={title:"routes",hash:"routes"},c={title:"options",hash:"options"},i={title:"Arguments",hash:"arguments",children:[s,u,c]},m={title:"navigate(details)",hash:"navigate"},h={title:"once(fn, options)",hash:"once"},p={title:"observe(fn, options)",hash:"observe"},d={title:"cancel(fn)",hash:"cancel-property"},E={title:"current()",hash:"current-property"},f={title:"route",hash:"router-route"},b={title:"history",hash:"history-property"},g={title:"external",hash:"router-external"},y={title:"Router",hash:"router",children:[m,h,p,d,E,f,b,g]},v={title:"createRouter()",hash:"curi",children:[i,y]};function w(){return l.a.createElement(r.e,{meta:v},l.a.createElement("p",null,"The ",l.a.createElement(r.f,null,"createRouter")," function is used to create a router. It has two required arguments: a ",l.a.createElement(r.f,null,"history")," object and a"," ",l.a.createElement(r.f,null,"routes")," array, and an optional third argument: an"," ",l.a.createElement(r.f,null,"options")," object."),l.a.createElement(r.d,null,'import { createRouter } from "@curi/router";\n\nconst router = createRouter(browser, routes, options);'),l.a.createElement(r.e,{tag:"h4",meta:i},l.a.createElement(r.e,{tag:"h5",meta:s},l.a.createElement("p",null,"A ",l.a.createElement("a",{href:"https://github.com/pshrmn/hickory"},"Hickory")," history function. The"," ",l.a.createElement(o.a,{name:"Guide",params:{slug:"history"}},"history guide")," ","provides more information on how to choose which history type is right for an application."),l.a.createElement(r.d,{lang:"jsx"},'import { browser } from "@hickory/browser";\n\nconst router = createRouter(browser, routes);')),l.a.createElement(r.e,{tag:"h5",meta:u},l.a.createElement("p",null,"An array of prepared"," ",l.a.createElement(o.a,{name:"Guide",params:{slug:"routes"}},"route")," ","objects describing all valid routes in the application."),l.a.createElement(r.d,{lang:"jsx"},'const routes = prepareRoutes([\n  { name: "Home", path: "" },\n  { name: "About", path: "about" }\n]);\n\nconst router = createRouter(browser, routes);')),l.a.createElement(r.e,{tag:"h5",meta:c},l.a.createElement("p",null,"An optional object with additional properties that can be passed to the router."),l.a.createElement(r.e,{tag:"h6",meta:{title:l.a.createElement(r.f,null,"route"),hash:"options-route"}},l.a.createElement("p",null,"An array of"," ",l.a.createElement(o.a,{name:"Guide",params:{slug:"route-interactions"}},"route interactions"),". These are functions for interacting with routes based on their"," ",l.a.createElement(r.f,null,"name"),"."),l.a.createElement("p",null,"The ",l.a.createElement(r.f,null,"pathname")," interaction is included by default; any other interactions are provided through this array."),l.a.createElement(r.d,null,'import active from "@curi/route-active";\nimport ancestors from "@curi/route-ancestors";\n\nconst routes = prepareRoutes([{ name: "Home", path: "" }]);\n\nconst router = createRouter(browser, routes, {\n  route: [active(), ancestors()]\n});'),l.a.createElement("p",null,"Route interactions are called via the router's ",l.a.createElement(r.f,null,"route")," ","object."),l.a.createElement(r.d,null,'router.route.active("Home");\n// returns true when location.pathname = "/"\n\nrouter.route.pathname("Home");\n// returns "/"')),l.a.createElement(r.e,{tag:"h6",meta:{title:l.a.createElement(r.f,null,"sideEffects"),hash:"options-sideEffects"}},l.a.createElement("p",null,"An array of"," ",l.a.createElement(o.a,{name:"Guide",params:{slug:"side-effects"}},"side effect")," ","objects."),l.a.createElement(r.i,null,l.a.createElement("thead",null,l.a.createElement("tr",null,l.a.createElement("th",null,"property"),l.a.createElement("th",null,"description"))),l.a.createElement("tbody",null,l.a.createElement("tr",null,l.a.createElement("td",null,"effect"),l.a.createElement("td",null,"An observer that will be called whenever a response is generated.")),l.a.createElement("tr",null,l.a.createElement("td",null,"after"),l.a.createElement("td",null,"(default ",l.a.createElement(r.f,null,"false"),") controls whether the side effect is called before or after non-side effect observers.")))),l.a.createElement(r.d,null,'import scroll from "@curi/side-effect-scroll";\n\nconst router = createRouter(browser, routes, {\n  sideEffects: [scroll()]\n});')),l.a.createElement(r.e,{tag:"h6",meta:{title:l.a.createElement(r.f,null,"external"),hash:"options-external"}},l.a.createElement("p",null,"Values that should be accessible to a route's ",l.a.createElement(r.f,null,"resolve")," ","function ",l.a.createElement(r.f,null,"response")," functions."),l.a.createElement("p",null,"Using ",l.a.createElement(r.f,null,"external")," allows you to access APIs, data, etc. without having to be able to import it in the module where the routes are defined."),l.a.createElement(r.d,null,'const client = new ApolloClient();\nconst router = createRouter(browser, routes, {\n  external: { client, greeting: "Hi!" }\n});'),l.a.createElement(r.d,null,'const routes = prepareRoutes([\n  {\n    name: "User",\n    path: "user/:id",\n    resolve(match, external) {\n      // use the external object to make a query\n      return external.client.query();\n    }\n  }\n]);')),l.a.createElement(r.e,{tag:"h6",meta:{title:l.a.createElement(r.f,null,"emitRedirects"),hash:"options-emitRedirects"}},l.a.createElement("p",null,"When ",l.a.createElement(r.f,null,"false")," (default is ",l.a.createElement(r.f,null,"true"),"), response objects with the ",l.a.createElement(r.f,null,"redirectTo")," property"," ",l.a.createElement("strong",null,"will not be emitted")," to observers. This can be useful for avoiding an extra render, but should not be used on the server."),l.a.createElement(r.d,null,'const routes = prepareRoutes([\n  {\n    name: "Old",\n    path: "old/:id",\n    response({ params }) {\n      // setup a redirect to the "New" route\n      return {\n        redirectTo: {\n          name: "New",\n          params\n        }\n      };\n    }\n  },\n  {\n    name: "New",\n    path: "new/:id"\n  }\n]);\n\nconst router = createRouter(browser, routes, {\n  emitRedirects: false\n});\n// navigating to "/old/2" will automatically redirect\n// to "/new/2" without emitting a response')))),l.a.createElement(r.e,{tag:"h4",meta:y},l.a.createElement("p",null,"The router has a number of properties for you to use when rendering your application."),l.a.createElement(r.e,{tag:"h5",meta:m},l.a.createElement("p",null,"The ",l.a.createElement(r.f,null,"navigate()")," method is used to navigate programmatically. It takes a ",l.a.createElement(r.f,null,"details")," object with the details of where you want to navigate to as well as the"," ",l.a.createElement(r.f,null,"method")," of navigation."),l.a.createElement(r.i,null,l.a.createElement("thead",null,l.a.createElement("tr",null,l.a.createElement("th",null,"property"),l.a.createElement("th",null,"description"))),l.a.createElement("tbody",null,l.a.createElement("tr",null,l.a.createElement("td",null,"name"),l.a.createElement("td",null,"The name of the route to navigate to")),l.a.createElement("tr",null,l.a.createElement("td",null,"params"),l.a.createElement("td",null,"An object of any route params for the named route (and any of its ancestors that require params).")),l.a.createElement("tr",null,l.a.createElement("td",null,"hash"),l.a.createElement("td",null,"The hash string of the location to navigate to.")),l.a.createElement("tr",null,l.a.createElement("td",null,"query"),l.a.createElement("td",null,"The query value of the location to navigate to.")),l.a.createElement("tr",null,l.a.createElement("td",null,"state"),l.a.createElement("td",null,"Any serializable state to attach to the location.")),l.a.createElement("tr",null,l.a.createElement("td",null,"method"),l.a.createElement("td",null,"How to navigate. ",l.a.createElement(r.f,null,'"push"')," appends the new location after the current one. ",l.a.createElement(r.f,null,'"replace"')," replaces the current location. ",l.a.createElement(r.f,null,'"anchor"')," is the default method and acts like clicking a link. This behavior is a mix of"," ",l.a.createElement(r.f,null,'"push"')," and ",l.a.createElement(r.f,null,'"replace"')," where the current location is replaced if the new location has the exact same URL.")),l.a.createElement("tr",null,l.a.createElement("td",null,"finished"),l.a.createElement("td",null,"A function to call once the navigation has finished.")),l.a.createElement("tr",null,l.a.createElement("td",null,"cancelled"),l.a.createElement("td",null,"A function to call if the navigation is superseded by another navigation.")))),l.a.createElement(r.d,null,'const routes = prepareRoutes([\n  {\n    name: "Album",\n    path: "photos/:albumID",\n    children: [\n      { name: "Photo", path: ":photoID" }\n    ]\n  },\n  // ...\n]);\nconst router = createRouter(browser, routes);\n\nrouter.navigate({\n  name: "Photo",\n  params: { albumID: 123, photoID: 456 }\n});\n// navigates to "/photos/123/456"\n// using default "anchor" method')),l.a.createElement(r.e,{tag:"h5",meta:h},l.a.createElement("p",null,"The ",l.a.createElement(r.f,null,"once()")," method takes a response handler function. If a response already exists, the function will be called immediately. Otherwise, the function will be called once a new response is created. The ",l.a.createElement(r.f,null,"{ initial: false }")," option can be used to prevent an immediate call even if a response already exists."),l.a.createElement(r.i,null,l.a.createElement("thead",null,l.a.createElement("tr",null,l.a.createElement("th",null,"property"),l.a.createElement("th",null,"description"))),l.a.createElement("tbody",null,l.a.createElement("tr",null,l.a.createElement("td",null,"response"),l.a.createElement("td",null,"The generated response object.")),l.a.createElement("tr",null,l.a.createElement("td",null,"navigation"),l.a.createElement("td",null,"The navigation's ",l.a.createElement(r.f,null,"action")," (",l.a.createElement(r.f,null,"push"),","," ",l.a.createElement(r.f,null,"replace"),", or ",l.a.createElement(r.f,null,"pop"),") and the"," ",l.a.createElement(r.f,null,"previous")," response object.")),l.a.createElement("tr",null,l.a.createElement("td",null,"router"),l.a.createElement("td",null,"The Curi router")))),l.a.createElement("p",null,"When a matched route is async (it has a ",l.a.createElement(r.f,null,"resolve")," ","function), a response will not be created until the function has resolved."),l.a.createElement(r.d,null,"router.once(({ response }) => {\n  // render the application based on the response\n});"),l.a.createElement(r.e,{tag:"h6",meta:{title:"options",hash:"once-options"}},l.a.createElement("div",{style:{overflowX:"scroll"}},l.a.createElement(r.i,null,l.a.createElement("thead",null,l.a.createElement("tr",null,l.a.createElement("th",null,"option"),l.a.createElement("th",null,"default"),l.a.createElement("th",null,"description"))),l.a.createElement("tbody",null,l.a.createElement("tr",null,l.a.createElement("td",null,"initial"),l.a.createElement("td",null,"true"),l.a.createElement("td",null,"When true, the function will be called immediately if a response exists. When false, the response function will not be called until the next response is emitted."))))),l.a.createElement(r.d,null,"router.once(responseHandler, {\n  initial: false\n});"))),l.a.createElement(r.e,{tag:"h5",meta:p},l.a.createElement("p",null,"The ",l.a.createElement(r.f,null,"observe()")," method takes a response handler function. The response handler will be called every time a new response is emitted (and it a response already exists, the function will be called immediately). The ",l.a.createElement(r.f,null,"{ initial: false }")," option can be used to prevent an immediate call even if a response already exists."),l.a.createElement(r.i,null,l.a.createElement("thead",null,l.a.createElement("tr",null,l.a.createElement("th",null,"property"),l.a.createElement("th",null,"description"))),l.a.createElement("tbody",null,l.a.createElement("tr",null,l.a.createElement("td",null,"response"),l.a.createElement("td",null,"The generated response object.")),l.a.createElement("tr",null,l.a.createElement("td",null,"navigation"),l.a.createElement("td",null,"The navigation's ",l.a.createElement(r.f,null,"action")," (",l.a.createElement(r.f,null,"push"),","," ",l.a.createElement(r.f,null,"replace"),", or ",l.a.createElement(r.f,null,"pop"),") and the"," ",l.a.createElement(r.f,null,"previous")," response object.")),l.a.createElement("tr",null,l.a.createElement("td",null,"router"),l.a.createElement("td",null,"The Curi router")))),l.a.createElement("p",null,"When a matched route is async (it has a ",l.a.createElement(r.f,null,"resolve")," ","function), a response will not be created until the function has resolved."),l.a.createElement(r.d,null,"router.observe(({ response }) => {\n  // render the application based on the response\n});"),l.a.createElement(r.e,{tag:"h6",meta:{title:"options",hash:"observe-options"}},l.a.createElement("div",{style:{overflowX:"scroll"}},l.a.createElement(r.i,null,l.a.createElement("thead",null,l.a.createElement("tr",null,l.a.createElement("th",null,"option"),l.a.createElement("th",null,"default"),l.a.createElement("th",null,"description"))),l.a.createElement("tbody",null,l.a.createElement("tr",null,l.a.createElement("td",null,"initial"),l.a.createElement("td",null,"true"),l.a.createElement("td",null,"When true, the function will be called immediately if a response exists. When false, the response function will not be called until the next response is emitted."))))),l.a.createElement(r.d,null,"router.observe(responseHandler, {\n  initial: false\n});"),l.a.createElement("p",null,l.a.createElement(r.f,null,"observe()")," returns a function to stop calling the response handler function for new responses."),l.a.createElement(r.d,null,"const stopObserving = router.observe(\n  () => {...}\n);\n// the router will now call the observer for all responses\n\nstopObserving();\n// the router no longer calls the observer"))),l.a.createElement(r.e,{tag:"h5",meta:d},l.a.createElement("p",null,"With asynchronous routes, after a user begins navigation, but before the route's asynchronous actions have finished, the user does not have a good way to cancel the navigation. They can either refresh the page (causing a full reload) or click a link with the same URL as the current location, but neither of these are intuitive or ideal."),l.a.createElement("p",null,l.a.createElement(r.f,null,"cancel()")," takes an observer function that will be called when navigation starts and when the navigation is finished. When the navigation starts, the observer function will be given a function to cancel the navigation. When the navigation finishes, the function will be called with ",l.a.createElement(r.f,null,"undefined"),"."),l.a.createElement("p",null,"Calling ",l.a.createElement(r.f,null,"cancel()")," returns a function to stop observing."),l.a.createElement(r.d,null,"const stopCancelling = router.cancel(fn => {\n  if (fn === undefined) {\n    // the navigation has finished/been cancelled\n  } else {\n    // calling fn will cancel the navigation\n  }\n});")),l.a.createElement(r.e,{tag:"h5",meta:E},l.a.createElement("p",null,"The ",l.a.createElement(r.f,null,"router.current()")," method returns the current"," ",l.a.createElement(r.f,null,"response")," and ",l.a.createElement(r.f,null,"navigation")," objects."),l.a.createElement(r.g,null,l.a.createElement("p",null,"If you call ",l.a.createElement(r.f,null,"router.current()")," before the initial response has been emitted, the ",l.a.createElement(r.f,null,"response")," and"," ",l.a.createElement(r.f,null,"navigation")," properties will be ",l.a.createElement(r.f,null,"null"),".")),l.a.createElement(r.d,null,"const router = createRouter(browser, routes);\nconst tooSoon = router.current();\n// tooSoon.response === null\n// tooSoon.navigation === null\n\nrouter.once(({ response, navigation }) => {\n  const perfect = router.current();\n  // perfect.response === response\n  // perfect.navigation === navigation\n});")),l.a.createElement(r.e,{tag:"h5",meta:f},l.a.createElement("p",null,"The router's"," ",l.a.createElement(o.a,{name:"Guide",params:{slug:"route-interactions"}},"route interactions")," ","are accessed through the ",l.a.createElement(r.f,null,"route")," property. These are used to interact with routes using their names."),l.a.createElement(r.e,{tag:"h6",meta:{title:"pathname",hash:"pathname-interaction"}},l.a.createElement("p",null,"Curi includes one built-in interaction, ",l.a.createElement(r.f,null,"pathname"),", which generates location pathnames using the name of a route and an optional object containing any necessary params."),l.a.createElement(r.d,null,"const routes = prepareRoutes([\n  { name: 'User', path: 'user/:id' }\n]);\nconst router = createRouter(browser, routes);\nconst userPathname = router.route.pathname(\n  'User',\n  { id: '12345' }\n);\n// userPathname === '/user/12345'"))),l.a.createElement(r.e,{tag:"h5",meta:b},l.a.createElement("p",null,"The route's history object, in case you need to interact directly with that.")),l.a.createElement(r.e,{tag:"h5",meta:g},l.a.createElement("p",null,"The ",l.a.createElement(r.f,null,"external")," value that was passed through"," ",l.a.createElement(o.a,{hash:"options-external"},l.a.createElement(r.f,null,"createRouter"),"'s options"),"."))))}var T={title:"prepareRoutes()",hash:"prepareRoutes"};function j(){return l.a.createElement(r.e,{meta:T},l.a.createElement("p",null,"The ",l.a.createElement(r.f,null,"prepareRoutes()")," export is used to build the routes for Curi. This will pre-compile paths for location matching and pathname building, which is particularly useful for server rendering."),l.a.createElement(r.d,null,'import { prepareRoutes } from \'@curi/router\';\n\nconst routes = prepareRoutes([\n  { name: "Home", path: "" },\n  // ...\n  { name: "Not Found", path: "(.*)" }\n]);'))}var x={title:"Route Objects",hash:"route-objects"};function R(){return l.a.createElement(r.e,{meta:x},l.a.createElement(r.e,{meta:{title:"route.name",hash:"name"},tag:"h3"},l.a.createElement("p",null,"A string, this must be unique for every route."),l.a.createElement(r.d,null,"[\n  { name: 'Home' },\n  { name: 'Album' },\n  { name: 'Not Found' }\n];")),l.a.createElement(r.e,{meta:{title:"route.path",hash:"path"},tag:"h3"},l.a.createElement("p",null,"A string pattern describing what the route matches. Whenever the router receives a new location, it will loop through the known route paths to determine which one matches the new location's"," ",l.a.createElement(r.f,null,"pathname")," the best."),l.a.createElement("p",null,"Curi uses"," ",l.a.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp#parameters"},l.a.createElement(r.f,null,"path-to-regexp"))," ","for path matching, which enables routes to have"," ",l.a.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp#parameters"},"path parameters"),". When a route with parameters matches a location, the parameters will be be parsed from the location's ",l.a.createElement(r.f,null,"pathname"),"."),l.a.createElement("p",null,l.a.createElement(r.f,null,"path")," strings should ",l.a.createElement("strong",null,"not")," have a leading slash."),l.a.createElement(r.d,null,"[\n  { name: 'Home', path: '' },\n  // when the pathname is a/yo, albumID = \"yo\"\n  { name: 'Album', path: 'a/:albumID' },\n  // the path (.*) matches every pathname\n  { name: 'Not Found', path: '(.*)' }\n];\n\n// don't include a leading forward slash\n// { name: 'Home', path: '/' }"),l.a.createElement(r.j,null,l.a.createElement("p",null,l.a.createElement(r.f,null,"path-to-regexp")," supports arrays and RegExps, but Curi only supports string paths."))),l.a.createElement(r.e,{meta:{title:"route.resolve",hash:"resolve"},tag:"h3"},l.a.createElement("p",null,"The ",l.a.createElement(r.f,null,"resolve")," property is a function that returns a Promise. It is used to run asynchronous actions for a route prior to rendering."),l.a.createElement("p",null,"A route with a ",l.a.createElement(r.f,null,"resolve")," function is asynchronous, while one with no ",l.a.createElement(r.f,null,"resolve")," functions is synchronous. You can read more about this in the"," ",l.a.createElement(o.a,{name:"Guide",params:{slug:"sync-or-async"}},"sync or async")," ","guide."),l.a.createElement("p",null,"The ",l.a.createElement(r.f,null,"resolve")," function is called every time that a route matches the current location."),l.a.createElement("p",null,"The function will be passed an object with the matched route properties: ",l.a.createElement(r.f,null,"name"),", ",l.a.createElement(r.f,null,"params"),", ",l.a.createElement(r.f,null,"partials"),", and ",l.a.createElement(r.f,null,"location"),"."),l.a.createElement(r.d,null,"const about = {\n  name: 'About',\n  path: 'about',\n  resolve({ name, params, partials, location }) {\n    return Promise.resolve(\"hurray!\");\n  }\n};"),l.a.createElement(r.g,null,l.a.createElement("p",null,"You should not perform side effects (e.g. passing the loaded data to a Redux store) in ",l.a.createElement(r.f,null,"resolve")," because it is possible that navigating to the route might be cancelled. If you must perform side effects for a route, you should do so in the route's"," ",l.a.createElement(r.f,null,"response")," function.")),l.a.createElement("p",null,"The value resolved by the ",l.a.createElement(r.f,null,"resolve")," function will be passed to the route's ",l.a.createElement(r.f,null,"response")," function through its"," ",l.a.createElement(r.f,null,"resolved")," property. If there is an uncaught error,"," ",l.a.createElement(r.f,null,"resolved")," will be ",l.a.createElement(r.f,null,"null")," and the ",l.a.createElement(r.f,null,"error")," ","will be passed."),l.a.createElement(r.d,null,"const about = {\n  name: 'About',\n  path: 'about',\n  resolve({ name, params, partials, location }) {\n    return Promise.resolve(\"hurray!\");\n  },\n  response({ resolved, error }) {\n    if (error) {\n      // there was an uncaught error in the resolve function\n    }\n  }\n};")),l.a.createElement(r.e,{meta:{title:"route.response()",hash:"response"}},l.a.createElement("p",null,'A function for modifying the response object. This returns an object whose properties will be merged with the matched route properties to create the "final" response.'),l.a.createElement("p",null,"Only valid properties will be merged onto the response; everything else will be ignored. The valid properties are:"),l.a.createElement("ol",null,l.a.createElement("li",null,l.a.createElement("p",null,l.a.createElement(r.f,null,"body")," - This is usually what you will render."),l.a.createElement(r.d,null,'import Home from "./components/Home";\nconst routes = prepareRoutes([\n  {\n    name: "Home",\n    path: "",\n    response() {\n      return { body: Home };\n    }\n  },\n  // ...\n]);\n// response = { body: Home, ... }')),l.a.createElement("li",null,l.a.createElement("p",null,l.a.createElement(r.f,null,"status")," - A number. This is useful for redirects or locations caught by your catch-all route while using server-side rendering. The default status value is ",l.a.createElement(r.f,null,"200"),"."),l.a.createElement(r.d,null,"{\n  response(){\n    return {\n      status: 301,\n      redirectTo: {...}\n    };\n  }\n}\n// response = { status: 301, ... }")),l.a.createElement("li",null,l.a.createElement("p",null,l.a.createElement(r.f,null,"error")," - If an error occurs with the route's"," ",l.a.createElement(r.f,null,"resolve")," function, you might want to attach an error message to the response."),l.a.createElement(r.d,null,'{\n  resolve() {\n    return Promise.reject("woops!");\n  },\n  response({ error }) {\n    return { error };\n  }\n}\n// response = { error: "woops!", ... }')),l.a.createElement("li",null,l.a.createElement("p",null,l.a.createElement(r.f,null,"data")," - Anything you want it to be."),l.a.createElement(r.d,null,"{\n  response() {\n    return { data: Math.random() };\n  }\n}\n// response = { data: 0.8651606708109429, ... }")),l.a.createElement("li",null,l.a.createElement("p",null,l.a.createElement(r.f,null,"title")," - This can be used with"," ",l.a.createElement(r.f,null,"@curi/side-effect-title")," to update the page's"," ",l.a.createElement(r.f,null,"document.title"),"."),l.a.createElement(r.d,null,'{\n  response({ params }) {\n    return { title: `User ${params.id}` };\n  }\n}\n// when visting /user/2\n// response = { title: "User 2", ... }')),l.a.createElement("li",null,l.a.createElement("p",null,l.a.createElement(r.f,null,"redirectTo")," - An object with the ",l.a.createElement(r.f,null,"name")," of the route to redirect to, ",l.a.createElement(r.f,null,"params")," (if required), and optional ",l.a.createElement(r.f,null,"hash"),", ",l.a.createElement(r.f,null,"query"),", and ",l.a.createElement(r.f,null,"state")," ","properties."),l.a.createElement("p",null,"The other values are copied directly, but ",l.a.createElement(r.f,null,"redirectTo")," ","will be turned into a location object using the object's"," ",l.a.createElement(r.f,null,"name")," (and ",l.a.createElement(r.f,null,"params")," if required)."),l.a.createElement(r.d,null,'[\n  {\n    name: "Old Photo",\n    path: "photo/:id",\n    response({ params }) {\n      return {\n        redirectTo: { name: "Photo", params }\n      };\n    }\n  },\n  {\n    name: "New Photo",\n    path: "p/:id"\n  }\n]\n// when the user navigates to /photo/1:\n// response = { redirectTo: { pathname: "/p/1", ... } }'))),l.a.createElement("p",null,"This function is passed an object with a number of properties that can be useful for modifying the response."),l.a.createElement(r.d,null,"{\n  response: ({ match, resolved, error }) => {\n    // ...\n  }\n}"),l.a.createElement(r.e,{meta:{title:"match",hash:"response-match"},tag:"h3"},l.a.createElement("p",null,"An object with the matched route properties of a response."),l.a.createElement(r.i,null,l.a.createElement("thead",null,l.a.createElement("tr",null,l.a.createElement("th",null,"property"),l.a.createElement("th",null,"description"))),l.a.createElement("tbody",null,l.a.createElement("tr",null,l.a.createElement("td",null,"name"),l.a.createElement("td",null,"the name of the matched route")),l.a.createElement("tr",null,l.a.createElement("td",null,"params"),l.a.createElement("td",null,"route parameters parsed from the location")),l.a.createElement("tr",null,l.a.createElement("td",null,"partials"),l.a.createElement("td",null,"the names of any ancestor routes of the matched route")),l.a.createElement("tr",null,l.a.createElement("td",null,"location"),l.a.createElement("td",null,"the location that was used to match the route")),l.a.createElement("tr",null,l.a.createElement("td",null,"key"),l.a.createElement("td",null,"a two number tuple. The first number is the location's place in the session array. The second number starts and zero and is incremented by ",l.a.createElement(r.f,null,"replace")," navigation (",l.a.createElement(r.f,null,"[1,0]")," ","would be replaced by ",l.a.createElement(r.f,null,"[1,1]"),")."))))),l.a.createElement(r.e,{meta:{title:"resolved",hash:"response-resolved"},tag:"h3"},l.a.createElement("p",null,l.a.createElement(r.f,null,"resolved")," is an object with the values resolved by the"," ",l.a.createElement(r.f,null,"resolve")," functions."),l.a.createElement("p",null,"If a route isn't async, ",l.a.createElement(r.f,null,"resolved")," will be ",l.a.createElement(r.f,null,"null"),"."),l.a.createElement(r.d,null,"// attach resolved data to the response\nconst user = {\n  name: 'User',\n  path: ':id',\n  resolve({ params, location }) {\n    return fetch(`/api/users/${params.id}`)\n      .then(resp => JSON.parse(resp));\n  },\n  response: ({ resolved }) => {\n    return {\n      data: resolved\n    };\n  }\n}")),l.a.createElement(r.e,{meta:{title:"error",hash:"response-error"},tag:"h3"},l.a.createElement("p",null,l.a.createElement(r.f,null,"error")," is an uncaught error thrown by the route's"," ",l.a.createElement(r.f,null,"resolve")," function."),l.a.createElement(r.d,null,"// check if any of a route's resolve functions threw\nconst user = {\n  name: 'User',\n  path: ':id',\n  resolve({ params, location }) {\n    return fetch(`/api/users/${params.id}`)\n      .then(resp => JSON.parse(resp));\n  },\n  response: ({ error, resolved }) => {\n    if (error) {\n      return { error };\n    }\n    return {\n      data: resolved.data\n    };\n  }\n}"))),l.a.createElement(r.e,{meta:{title:"children",hash:"children"},tag:"h3"},l.a.createElement("p",null,"An optional array of route objects for creating nested routes. Any child routes will be matched relative to their parent route's"," ",l.a.createElement(r.f,null,"path"),". This means that if a parent route's ",l.a.createElement(r.f,null,"path")," ","string is ",l.a.createElement(r.f,null,"'one'")," and a child route's ",l.a.createElement(r.f,null,"path")," string is ",l.a.createElement(r.f,null,"'two'"),", the child will match when the pathname is"," ",l.a.createElement(r.f,null,"'one/two'"),"."),l.a.createElement(r.d,null,"// '/a/Coloring+Book/All+Night' will be matched\n// by the \"Song\" route, with the params\n// { album: 'Coloring+Book', title: 'All+Night' }\n{\n  name: 'Album',\n  path: 'a/:album',\n  children: [\n    {\n      name: 'Song',\n      path: ':title'\n    }\n  ]\n}")),l.a.createElement(r.e,{meta:{title:"params",hash:"params"},tag:"h3"},l.a.createElement("p",null,"When ",l.a.createElement(r.f,null,"path-to-regexp")," matches your paths, all parameters are extracted as strings. If you prefer for some route params to be other types, you can provide functions to transform params using the"," ",l.a.createElement(r.f,null,"route.params")," object."),l.a.createElement("p",null,"Properties of the ",l.a.createElement(r.f,null,"route.params")," object are the names of params to be parsed. The paired value should be a function that takes a string (the value from the ",l.a.createElement(r.f,null,"pathname"),") and returns a new value (transformed using the function you provide)."),l.a.createElement(r.d,null,"const routes = prepareRoutes([\n  {\n    name: 'Number',\n    path: 'number/:num',\n    params: {\n      num: n => parseInt(n, 10)\n    }\n  }\n]);\n\n// when the user visits /number/1,\n// response.params will be { num: 1 }\n// instead of { num: \"1\" }")),l.a.createElement(r.e,{meta:{title:"pathOptions",hash:"pathOptions"},tag:"h3"},l.a.createElement("p",null,"Curi uses"," ",l.a.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp"},l.a.createElement(r.f,null,"path-to-regexp"))," ","to handle route matching and pathname generation. Each route can configure both its route matching and pathname generation through its"," ",l.a.createElement(r.f,null,"pathOptions")," property."),l.a.createElement(r.g,null,l.a.createElement("p",null,"If a route has a children array property, it will"," ",l.a.createElement("strong",null,"always")," have the ",l.a.createElement(r.f,null,"end")," path option set to"," ",l.a.createElement(r.f,null,"false"),".")),l.a.createElement("p",null,"For route matching, the options are passed through a ",l.a.createElement(r.f,null,"match")," ","object. You can see the options and their default values in the"," ",l.a.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp#usage"},l.a.createElement(r.f,null,"path-to-regexp")," documentation"),"."),l.a.createElement("p",null,"For pathname generation, the options are passed through a"," ",l.a.createElement(r.f,null,"compile")," object. There is only one possible option, which is an ",l.a.createElement(r.f,null,"encode")," function for encoding params. The default"," ",l.a.createElement(r.f,null,"encode")," function encodes params using"," ",l.a.createElement(r.f,null,"encodeURIComponent"),"."),l.a.createElement(r.d,null,'{\n  name: "My Route",\n  path: "my/:item",\n  pathOptions: {\n    match: {\n      sensitive: false\n    },\n    compile: {\n      encode: (value, token) => value\n    }\n  }\n}')),l.a.createElement(r.e,{meta:{title:"extra",hash:"extra"},tag:"h3"},l.a.createElement("p",null,"If you have any additional properties that you want attached to a route, use the ",l.a.createElement(r.f,null,"extra")," property. You will be able to use"," ",l.a.createElement(r.f,null,"route.extra")," in any custom route interactions."),l.a.createElement(r.d,null,"const routes = prepareRoutes([\n  {\n    name: 'A Route',\n    path: 'a-route',\n    extra: {\n      transition: 'fade'\n    }\n  },\n  {\n    name: 'B Route',\n    path: 'b-route',\n    extra: {\n      enter: 'slide-right'\n    }\n  }\n]);")))}function A(e){return(A="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function k(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function I(e,t){return!t||"object"!==A(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function O(e){return(O=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function P(e,t){return(P=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}var H=function(e){function t(){return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),I(this,O(t).apply(this,arguments))}var n,a,o;return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&P(e,t)}(t,l.a.PureComponent),n=t,(a=[{key:"render",value:function(){return l.a.createElement(l.a.Fragment,null,l.a.createElement(r.b,null,l.a.createElement("p",null,"The ",l.a.createElement(r.f,null,"@curi/router")," package is used to create a router.")),l.a.createElement(r.a,null,l.a.createElement(w,null),l.a.createElement(j,null),l.a.createElement(R,null)))}}])&&k(n.prototype,a),o&&k(n,o),t}(),C=[{title:"Installation",hash:"installation"},{title:"About",hash:"about"},{title:"API",hash:"API",children:[v,T,x]}];n.d(t,"component",function(){return H}),n.d(t,"contents",function(){return C})}}]);