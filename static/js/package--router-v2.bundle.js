(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{80:function(e,t,n){"use strict";n.r(t);var a=n(0),r=n.n(a),l=n(21),o=n(3),s={title:"history",hash:"history"},i={title:"routes",hash:"routes"},c={title:"options",hash:"options"},u={title:"Arguments",hash:"createRouter-arguments",children:[s,i,c]},h={title:"url",hash:"url"},m={title:"navigate",hash:"navigate"},p={title:"once",hash:"once"},d={title:"observe",hash:"observe"},f={title:"cancel",hash:"cancel-property"},E={title:"current",hash:"current-property"},g={title:"route",hash:"router-route"},b={title:"history",hash:"history-property"},v={title:"external",hash:"router-external"},y={title:"Router",hash:"router",children:[h,m,p,d,f,E,g,b,v]},w={title:"createRouter",hash:"createRouter",children:[u,y]};function R(){return r.a.createElement(l.e,{meta:w},r.a.createElement("p",null,"The ",r.a.createElement(l.f,null,"createRouter")," function is used to create a router."),r.a.createElement(l.d,null,'import { createRouter } from "@curi/router";\n\nconst router = createRouter(browser, routes, options);'),r.a.createElement(l.e,{tag:"h4",meta:u},r.a.createElement(l.e,{tag:"h5",meta:s},r.a.createElement("p",null,"A ",r.a.createElement("a",{href:"https://github.com/pshrmn/hickory"},"Hickory")," history function. The"," ",r.a.createElement(o.a,{name:"Guide",params:{slug:"history"}},"history guide")," ","provides more information on how to choose which history type is right for an application."),r.a.createElement(l.d,{lang:"jsx"},'import { browser } from "@hickory/browser";\n\nconst router = createRouter(browser, routes);')),r.a.createElement(l.e,{tag:"h5",meta:i},r.a.createElement("p",null,"An array of prepared"," ",r.a.createElement(o.a,{name:"Guide",params:{slug:"routes"}},"route")," ","objects describing all valid routes in the application."),r.a.createElement(l.d,{lang:"jsx"},'const routes = prepareRoutes([\n  { name: "Home", path: "" },\n  { name: "About", path: "about" }\n]);\n\nconst router = createRouter(browser, routes);')),r.a.createElement(l.e,{tag:"h5",meta:c},r.a.createElement("p",null,"An optional object with additional properties that can be passed to the router."),r.a.createElement(l.e,{tag:"h6",meta:{title:r.a.createElement(l.f,null,"sideEffects"),hash:"options-sideEffects"}},r.a.createElement("p",null,"An array of"," ",r.a.createElement(o.a,{name:"Guide",params:{slug:"side-effects"}},"side effect")," ","objects."),r.a.createElement(l.d,null,'import { createRouter, scroll } from "@curi/router";\n\nconst router = createRouter(browser, routes, {\n  sideEffects: [scroll()]\n});')),r.a.createElement(l.e,{tag:"h6",meta:{title:r.a.createElement(l.f,null,"external"),hash:"options-external"}},r.a.createElement("p",null,"Values that should be accessible to a route's ",r.a.createElement(l.f,null,"resolve")," ","function ",r.a.createElement(l.f,null,"respond")," functions."),r.a.createElement("p",null,"Using ",r.a.createElement(l.f,null,"external")," allows you to access APIs, data, etc. without having to import it in the module where the routes are defined."),r.a.createElement(l.d,null,'const client = new ApolloClient();\nconst router = createRouter(browser, routes, {\n  external: { client, greeting: "Hi!" }\n});'),r.a.createElement(l.d,null,'const routes = prepareRoutes([\n  {\n    name: "User",\n    path: "user/:id",\n    resolve(match, external) {\n      // use the external object to make a query\n      return external.client.query();\n    }\n  }\n]);')),r.a.createElement(l.e,{tag:"h6",meta:{title:r.a.createElement(l.f,null,"invisibleRedirects"),hash:"options-invisibleRedirects"}},r.a.createElement("p",null,"When a response object has a ",r.a.createElement(l.f,null,"redirect")," property, Curi will automatically navigate to the location specified by the property."),r.a.createElement("p",null,"If the ",r.a.createElement(l.f,null,"invisibleRedirects")," property is ",r.a.createElement(l.f,null,"false")," ","(the default), Curi will emit the redirect response (any observers will be called with the response)."),r.a.createElement("p",null,"If ",r.a.createElement(l.f,null,"invisibleRedirects")," is set to ",r.a.createElement(l.f,null,"true"),", Curi will skip emitting the redirect; this effectively makes the redirect invisible to the application."),r.a.createElement("p",null,r.a.createElement(l.f,null,"invisibleRedirects")," should always be ",r.a.createElement(l.f,null,"false")," ","for server-side rendering, otherwise the application will render content for the incorrect location."),r.a.createElement(l.d,null,'const routes = prepareRoutes([\n  {\n    name: "Old",\n    path: "old/:id",\n    respond({ params }) {\n      // setup a redirect to the "New" route\n      return {\n        redirect: {\n          name: "New",\n          params\n        }\n      };\n    }\n  },\n  {\n    name: "New",\n    path: "new/:id"\n  }\n]);\n\nconst router = createRouter(browser, routes, {\n  invisibleRedirects: false\n});\n// navigating to "/old/2" will automatically redirect\n// to "/new/2" without emitting a response for the Old route')))),r.a.createElement(l.e,{tag:"h4",meta:y},r.a.createElement("p",null,"The router has a number of properties for you to use when rendering your application."),r.a.createElement(l.e,{tag:"h5",meta:h},r.a.createElement("p",null,"The ",r.a.createElement(l.f,null,"url")," method is used to generate a URL string."),r.a.createElement(l.d,null,'router.url({\n  name: "User",\n  params: { id: 1 },\n  hash: "other"\n});'),r.a.createElement(l.e,{tag:"h6",meta:{title:"Arguments",hash:"url-args"}},r.a.createElement("p",null,r.a.createElement(l.f,null,"url")," takes a single argument, an object with details about the location to navigate to and how to navigate."),r.a.createElement(l.e,{tag:"h6",meta:{title:"name",hash:"url-name"}},r.a.createElement("p",null,"The name of a route.")),r.a.createElement(l.e,{tag:"h6",meta:{title:"params",hash:"url-params"}},r.a.createElement("p",null,"An object of any route params for the named route (and any of its ancestors that require params).")),r.a.createElement(l.e,{tag:"h6",meta:{title:"hash",hash:"url-hash"}},r.a.createElement("p",null,"The hash string of a location.")),r.a.createElement(l.e,{tag:"h6",meta:{title:"query",hash:"url-query"}},r.a.createElement("p",null,"The query value of a location.")))),r.a.createElement(l.e,{tag:"h5",meta:m},r.a.createElement("p",null,"The ",r.a.createElement(l.f,null,"navigate")," method is used to navigate programmatically. It takes an object with the details of where and how to navigate."),r.a.createElement(l.d,null,'router.navigate({ url: "/photos/123/456" });\n// navigates to "/photos/123/456"\n// using default "anchor" method'),r.a.createElement(l.e,{tag:"h6",meta:{title:"Arguments",hash:"navigate-args"}},r.a.createElement("p",null,r.a.createElement(l.f,null,"navigate")," takes a single argument, an object with details about the location to navigate to and how to navigate."),r.a.createElement(l.e,{tag:"h6",meta:{title:"url",hash:"navigate-url"}},r.a.createElement("p",null,"The URL string of the location to navigate to.")),r.a.createElement(l.e,{tag:"h6",meta:{title:"state",hash:"navigate-state"}},r.a.createElement("p",null,"Any serializable state to attach to the location.")),r.a.createElement(l.e,{tag:"h6",meta:{title:"method",hash:"navigate-method"}},r.a.createElement("p",null,"How to navigate. ",r.a.createElement(l.f,null,'"push"')," appends the new location after the current one. ",r.a.createElement(l.f,null,'"replace"')," replaces the current location. ",r.a.createElement(l.f,null,'"anchor"')," is the default method and acts like clicking a link. This behavior is a mix of"," ",r.a.createElement(l.f,null,'"push"')," and ",r.a.createElement(l.f,null,'"replace"')," where the current location is replaced if the new location has the exact same URL.")),r.a.createElement(l.e,{tag:"h6",meta:{title:"finished & cancelled",hash:"navigate-finished-cancelled"}},r.a.createElement("p",null,r.a.createElement(l.f,null,"finished")," is a function to call once the navigation has finished."),r.a.createElement("p",null,r.a.createElement(l.f,null,"cancelled")," is a function to call if the navigation is superseded by another navigation."),r.a.createElement("p",null,"These properties should only be provided when navigating to asynchronous routes. Synchronous routes navigate immediately, so there is no waiting time for the navigation.")))),r.a.createElement(l.e,{tag:"h5",meta:p},r.a.createElement("p",null,"Register a response handler that will only be called one time."),r.a.createElement("p",null,"When a matched route is async (it has a ",r.a.createElement(l.f,null,"resolve")," ","function), a response will not be created until the function has resolved. ",r.a.createElement(l.f,null,"once")," is useful for delaying an application's initial render."),r.a.createElement(l.d,null,"router.once(({ response }) => {\n  // render the application based on the response\n});"),r.a.createElement(l.e,{tag:"h6",meta:{title:"Arguments",hash:"once-args"}},r.a.createElement(l.e,{tag:"h6",meta:{title:"Response Handler",hash:"once-response-handler"}},r.a.createElement("p",null,"A function that will be called once the router has generated a response. If the router has already generated a response, the function will be called immediately with the existing response. Otherwise, the function will be called once a new response is generated."),r.a.createElement("p",null,"The function will be passed an object with three properties: the"," ",r.a.createElement(l.f,null,"response"),", a ",r.a.createElement(l.f,null,"navigation")," object, and the"," ",r.a.createElement(l.f,null,"router"),".")),r.a.createElement(l.e,{tag:"h6",meta:{title:"Options",hash:"once-options"}},r.a.createElement(l.e,{tag:"h6",meta:{title:"initial",hash:"once-options-initial"}},r.a.createElement("p",null,"When ",r.a.createElement(l.f,null,"true")," (the default), the response handler will be called immediately if there is an existing response. When"," ",r.a.createElement(l.f,null,"false"),", the response handler will not be called until a new response is generated."),r.a.createElement(l.d,null,"router.once(responseHandler, {\n  initial: false\n});"))))),r.a.createElement(l.e,{tag:"h5",meta:d},r.a.createElement("p",null,"Register a response handler that will be called every time a response is generated."),r.a.createElement("p",null,"When a matched route is async (it has a ",r.a.createElement(l.f,null,"resolve")," ","function), a response will not be created until the function has resolved."),r.a.createElement(l.d,null,"router.observe(({ response }) => {\n  // render the application based on the response\n});"),r.a.createElement("p",null,r.a.createElement(l.f,null,"observe")," returns a function, which can be called to stop observing."),r.a.createElement(l.d,null,"const stopObserving = router.observe(fn);\n// the router will call the response handler for all responses\n\nstopObserving();\n// the router no longer calls the response handler"),r.a.createElement(l.e,{tag:"h6",meta:{title:"Arguments",hash:"observe-args"}},r.a.createElement(l.e,{tag:"h6",meta:{title:"Response Handler",hash:"observe-response-handler"}},r.a.createElement("p",null,"A function that will be called whenever a new response is generated. If a response already exists when the function is called, the response handler will be called immediately with the existing response.")),r.a.createElement(l.e,{tag:"h6",meta:{title:"Options",hash:"observe-options"}},r.a.createElement(l.e,{tag:"h6",meta:{title:"initial",hash:"observe-options-initial"}},r.a.createElement("p",null,"When ",r.a.createElement(l.f,null,"true")," (the default), the response handler will be called immediately if there is an existing response. When"," ",r.a.createElement(l.f,null,"false"),", the response handler will not be called until a new response is generated."),r.a.createElement(l.d,null,"router.observe(responseHandler, {\n  initial: false\n});"))))),r.a.createElement(l.e,{tag:"h5",meta:f},r.a.createElement("p",null,"With navigating to an asynchronous route, there is a time between when a navigation begins and when the route's asynchronous actions have finished, during which a user may decide to cancel the navigation."),r.a.createElement("p",null,"In a multi-page application, the browser updates the refresh button to a stop button. There is no equivalent functionality for single-page applications, so Curi provides a ",r.a.createElement(l.f,null,"cancel")," ","function to roughly imitate the behavior."),r.a.createElement("p",null,r.a.createElement(l.f,null,"cancel")," takes an observer function that will be called when navigation starts and when the navigation is finished. When the navigation starts, the observer function will be called with a function to cancel the navigation. When the navigation finishes, the function will be called with ",r.a.createElement(l.f,null,"undefined"),"."),r.a.createElement("p",null,"Calling ",r.a.createElement(l.f,null,"cancel")," returns a function to stop observing."),r.a.createElement(l.d,null,"const stopCancelling = router.cancel(fn);\n// fn will be called for async navigation\n\nstopCancelling();\n// fn will no longer be called"),r.a.createElement(l.e,{tag:"h6",meta:{title:"Arguments",hash:"cancel-args"}},r.a.createElement(l.e,{tag:"h6",meta:{title:"Cancel Handler",hash:"cancel-handler"}},r.a.createElement("p",null,"A function that will be called when an asynchronous navigation begins and ends."),r.a.createElement("p",null,"When the navigation begins, the function will be passed a function that can be called to cancel the navigation."),r.a.createElement("p",null,"When the navigation ends, the function will be passed"," ",r.a.createElement(l.f,null,"undefined"),"."),r.a.createElement(l.d,null,"router.cancel(fn => {\n  if (fn === undefined) {\n    // the navigation has finished/been cancelled\n  } else {\n    // calling fn will cancel the navigation\n  }\n});"),r.a.createElement("p",null,"Calling the cancel handler after the navigation has ended does nothing.")))),r.a.createElement(l.e,{tag:"h5",meta:E},r.a.createElement("p",null,"The ",r.a.createElement(l.f,null,"current")," method returns the current"," ",r.a.createElement(l.f,null,"response")," and ",r.a.createElement(l.f,null,"navigation")," objects."),r.a.createElement(l.g,null,r.a.createElement("p",null,"If you call ",r.a.createElement(l.f,null,"current")," before the initial response has been generated, the ",r.a.createElement(l.f,null,"response")," and ",r.a.createElement(l.f,null,"navigation")," ","properties will be ",r.a.createElement(l.f,null,"null"),".")),r.a.createElement(l.d,null,"const router = createRouter(browser, routes);\nconst tooSoon = router.current();\n// tooSoon.response === null\n// tooSoon.navigation === null\n\nrouter.once(({ response, navigation }) => {\n  const perfect = router.current();\n  // perfect.response === response\n  // perfect.navigation === navigation\n});")),r.a.createElement(l.e,{tag:"h5",meta:g},r.a.createElement("p",null,"The ",r.a.createElement(l.f,null,"route")," method is used to get the public data about a route. This is useful in conjuction with"," ",r.a.createElement(o.a,{name:"Guide",params:{slug:"route-interactions"}},"route interactions"),".")),r.a.createElement(l.e,{tag:"h5",meta:b},r.a.createElement("p",null,"The route's history object.")),r.a.createElement(l.e,{tag:"h5",meta:v},r.a.createElement("p",null,"The ",r.a.createElement(l.f,null,"external")," value that was passed through"," ",r.a.createElement(o.a,{hash:"options-external"},r.a.createElement(l.f,null,"createRouter"),"'s options"),"."))))}var A={title:"routes",hash:"options-routes"},T={title:"Arguments",hash:"prepareRoutes-arguments",children:[A]},j={title:"prepareRoutes",hash:"prepareRoutes",children:[T]};function x(){return r.a.createElement(l.e,{meta:j},r.a.createElement("p",null,"The ",r.a.createElement(l.f,null,"prepareRoutes")," function takes an application's routes and route interactions and returns an object. The returned object will be passed to ",r.a.createElement(l.f,null,"createRouter"),"."),r.a.createElement(l.d,null,'import { prepareRoutes } from \'@curi/router\';\n\nconst routes = prepareRoutes([\n  { name: "Home", path: "" },\n  // ...\n  { name: "Not Found", path: "(.*)" }\n]);'),r.a.createElement("p",null,r.a.createElement(l.f,null,"prepareRoutes")," creates a reusable routing object, which means that it can be reused on the server instead of recompiling it for every request."),r.a.createElement(l.e,{tag:"h4",meta:T},r.a.createElement(l.e,{tag:"h5",meta:A},"An array of ",r.a.createElement(o.a,{hash:"route-objects"},"route objects"),".")))}var k={title:"Route Objects",hash:"route-objects"};function I(){return r.a.createElement(l.e,{meta:k},r.a.createElement(l.e,{meta:{title:"route.name",hash:"name"},tag:"h3"},r.a.createElement("p",null,"A string that will be used to identify a route. This must be unique for every route."),r.a.createElement(l.d,null,"[\n  { name: 'Home' },\n  { name: 'Album' },\n  { name: 'Not Found' }\n];")),r.a.createElement(l.e,{meta:{title:"route.path",hash:"path"},tag:"h3"},r.a.createElement("p",null,"A string pattern describing what the route matches. ",r.a.createElement(l.f,null,"path")," ","strings should not have a leading slash."),r.a.createElement(l.d,null,'[\n  { path: "" }, // yes\n  { path: "/" }, // no\n]'),r.a.createElement("p",null,"A route's ",r.a.createElement(l.f,null,"path")," is used to check if it matches a location's"," ",r.a.createElement(l.f,null,"pathname"),". When the ",r.a.createElement(l.f,null,"path")," matches, the route is selected."),r.a.createElement("p",null,"Path matching is done using regular expressions compiled by"," ",r.a.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp"},r.a.createElement(l.f,null,"path-to-regexp")),". A path can include"," ",r.a.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp#parameters"},"parameters"),", which are dynamic variables that are parsed from a location's"," ",r.a.createElement(l.f,null,"pathname"),". For advanced path formatting, please read"," ",r.a.createElement(l.f,null,"path-to-regexp"),"'s documentaion."),r.a.createElement(l.d,null,"[\n  { name: 'Home', path: '' },\n  // when the pathname is a/yo, albumID = \"yo\"\n  { name: 'Album', path: 'a/:albumID' },\n  // the path (.*) matches every pathname\n  { name: 'Not Found', path: '(.*)' }\n];\n\n// don't include a leading forward slash\n// { name: 'Home', path: '/' }"),r.a.createElement(l.j,null,r.a.createElement("p",null,r.a.createElement(l.f,null,"path-to-regexp")," supports arrays and RegExps, but Curi only supports string paths."))),r.a.createElement(l.e,{meta:{title:"route.resolve",hash:"resolve"},tag:"h3"},r.a.createElement("p",null,"The ",r.a.createElement(l.f,null,"resolve")," property is a function that returns a Promise. It is used to run asynchronous actions for a route prior to rendering."),r.a.createElement("p",null,"A route with a ",r.a.createElement(l.f,null,"resolve")," function is asynchronous, while one with no ",r.a.createElement(l.f,null,"resolve")," functions is synchronous. You can read more about this in the"," ",r.a.createElement(o.a,{name:"Guide",params:{slug:"sync-or-async"}},"sync or async")," ","guide."),r.a.createElement("p",null,"Every time that a route with a ",r.a.createElement(l.f,null,"resolve")," function matches, the route's ",r.a.createElement(l.f,null,"resolve")," function will be called. Simple caching can be done with the ",r.a.createElement(l.f,null,"once")," function from"," ",r.a.createElement(o.a,{name:"Package",params:{package:"helpers",version:"v2"},hash:"once"},r.a.createElement(l.f,null,"@curi/helpers")),", while more advanced caching is left to the user."),r.a.createElement("p",null,"The function will be passed an object with the matched route properties: ",r.a.createElement(l.f,null,"name"),", ",r.a.createElement(l.f,null,"params"),", ",r.a.createElement(l.f,null,"partials"),", and ",r.a.createElement(l.f,null,"location"),"."),r.a.createElement(l.d,null,"const about = {\n  name: 'About',\n  path: 'about',\n  resolve({ name, params, partials, location }) {\n    return Promise.resolve(\"hurray!\");\n  }\n};"),r.a.createElement(l.g,null,r.a.createElement("p",null,"You should not perform side effects (e.g. passing the loaded data to a Redux store) in ",r.a.createElement(l.f,null,"resolve")," because it is possible that navigating to the route might be cancelled. If you must perform side effects for a route, you should do so in the route's"," ",r.a.createElement(l.f,null,"respond")," function, but even that should be avoided.")),r.a.createElement("p",null,"The value returned by the ",r.a.createElement(l.f,null,"resolve")," function will be passed to the route's ",r.a.createElement(l.f,null,"respond")," function through its"," ",r.a.createElement(l.f,null,"resolved")," property. If there is an uncaught error,"," ",r.a.createElement(l.f,null,"resolved")," will be ",r.a.createElement(l.f,null,"null")," and the ",r.a.createElement(l.f,null,"error")," ","will be passed."),r.a.createElement(l.d,null,"const about = {\n  name: 'About',\n  path: 'about',\n  resolve({ name, params, partials, location }) {\n    return Promise.resolve(\"hurray!\");\n  },\n  respond({ resolved, error }) {\n    if (error) {\n      // there was an uncaught error in the resolve function\n    }\n  }\n};")),r.a.createElement(l.e,{meta:{title:"route.respond",hash:"respond"}},r.a.createElement("p",null,"A function for modifying the response object."),r.a.createElement("p",null,"The object returned by a route's ",r.a.createElement(l.f,null,"respond")," function will be merged with the route's intrinsic match properties to create the response object."),r.a.createElement("p",null,"Only valid properties will be merged onto the response; everything else will be ignored. The valid properties are:"),r.a.createElement(l.e,{tag:"h3",meta:{title:"Arguments",hash:"response-arguments"}},r.a.createElement(l.e,{tag:"h4",meta:{title:"options",hash:"response-options"}},r.a.createElement("p",null,"A ",r.a.createElement(l.f,null,"respond")," function is passed an object with a number of properties that can be useful for modifying the response."),r.a.createElement(l.d,null,"{\n  respond: ({ match, resolved, error }) => {\n    // ...\n  }\n}"),r.a.createElement(l.e,{tag:"h5",meta:{title:"match",hash:"response-options-match"}},r.a.createElement("p",null,"An object with the intrinsic route properties of a response."),r.a.createElement(l.e,{tag:"h6",meta:{title:"name",hash:"response-options-match-name"}},r.a.createElement("p",null,"The name of the matched route.")),r.a.createElement(l.e,{tag:"h6",meta:{title:"params",hash:"response-options-match-params"}},r.a.createElement("p",null,"Route parameters parsed from the location.")),r.a.createElement(l.e,{tag:"h6",meta:{title:"partials",hash:"response-options-match-partials"}},r.a.createElement("p",null,"The names of any ancestor routes of the matched route.")),r.a.createElement(l.e,{tag:"h6",meta:{title:"location",hash:"response-options-match-location"}},r.a.createElement("p",null,"The location that was used to match the route.")),r.a.createElement(l.e,{tag:"h6",meta:{title:"key",hash:"response-options-match-key"}},r.a.createElement("p",null,"A two number tuple. The first number is the location's place in the session array. The second number starts and zero and is incremented by ",r.a.createElement(l.f,null,"replace")," navigation (",r.a.createElement(l.f,null,"[1,0]")," ","would be replaced by ",r.a.createElement(l.f,null,"[1,1]"),")."))),r.a.createElement(l.e,{tag:"h5",meta:{title:"resolved",hash:"response-options-resolved"}},r.a.createElement("p",null,"An object with the value returned by the route's"," ",r.a.createElement(l.f,null,"resolve")," function."),r.a.createElement("p",null,"If a route isn't async, ",r.a.createElement(l.f,null,"resolved")," will be"," ",r.a.createElement(l.f,null,"null"),"."),r.a.createElement(l.d,null,"// attach resolved data to the response\nconst user = {\n  name: 'User',\n  path: ':id',\n  resolve({ params, location }) {\n    return fetch(`/api/users/${params.id}`)\n      .then(resp => JSON.parse(resp));\n  },\n  respond: ({ resolved }) => {\n    return {\n      data: resolved\n    };\n  }\n}")),r.a.createElement(l.e,{tag:"h5",meta:{title:"error",hash:"response-options-error"}},r.a.createElement("p",null,"If the route has a ",r.a.createElement(l.f,null,"resolve")," function that throws an uncaught error, the ",r.a.createElement(l.f,null,"error")," property will be that error. Otherwise, the property will be ",r.a.createElement(l.f,null,"null"),"."),r.a.createElement("p",null,"Ideally, the ",r.a.createElement(l.f,null,"resolve")," function will always catch its errors, but ",r.a.createElement(l.f,null,"error")," serves as a safety check."),r.a.createElement(l.d,null,"// check if any of a route's resolve functions threw\nconst user = {\n  name: 'User',\n  path: ':id',\n  resolve({ params, location }) {\n    return fetch(`/api/users/${params.id}`)\n      .then(resp => JSON.parse(resp));\n  },\n  respond: ({ error, resolved }) => {\n    if (error) {\n      return {\n        meta: {\n          error\n        }\n      };\n    }\n    return {\n      data: resolved.data\n    };\n  }\n}")))),r.a.createElement(l.e,{tag:"h3",meta:{title:"Return Value",hash:"response-return"}},r.a.createElement(l.e,{tag:"h4",meta:{title:"body",hash:"response-body"}},r.a.createElement("p",null,"Typically, the ",r.a.createElement(l.f,null,"body")," is a component (or components) that will be rendered."),r.a.createElement(l.d,null,'import Home from "./components/Home";\nconst routes = prepareRoutes([\n  {\n    name: "Home",\n    path: "",\n    respond() {\n      return { body: Home };\n    }\n  },\n  // ...\n]);\n// response = { body: Home, ... }')),r.a.createElement(l.e,{tag:"h4",meta:{title:"meta",hash:"response-return-meta"}},r.a.createElement("p",null,"An object whose properties are metadata about the response. This may include the status of the response (200, 301, etc.), a title string for the document, or a description to be set as a page's"," ",r.a.createElement(l.f,null,'<meta name="Description">'),"."),r.a.createElement(l.d,null,'{\n  respond(){\n    return {\n      meta: {\n        title: "Some Page",\n        description: "This is some page",\n        status: 200\n      }\n    };\n  }\n}')),r.a.createElement(l.e,{tag:"h4",meta:{title:"data",hash:"response-return-data"}},r.a.createElement("p",null,"Anything you want it to be."),r.a.createElement(l.d,null,"{\n  respond() {\n    return { data: Math.random() };\n  }\n}\n// response = { data: 0.8651606708109429, ... }")),r.a.createElement(l.e,{tag:"h4",meta:{title:"redirect",hash:"response-return-redirect"}},r.a.createElement("p",null,"An object with the ",r.a.createElement(l.f,null,"name")," of the route to redirect to,"," ",r.a.createElement(l.f,null,"params")," (if required), and optional ",r.a.createElement(l.f,null,"hash"),","," ",r.a.createElement(l.f,null,"query"),", and ",r.a.createElement(l.f,null,"state")," properties."),r.a.createElement("p",null,"The other values are copied directly, but ",r.a.createElement(l.f,null,"redirect")," will be turned into a location object using the object's"," ",r.a.createElement(l.f,null,"name")," (and ",r.a.createElement(l.f,null,"params")," if required)."),r.a.createElement(l.d,null,'[\n  {\n    name: "Old Photo",\n    path: "photo/:id",\n    respond({ params }) {\n      return {\n        redirect: { name: "Photo", params }\n      };\n    }\n  },\n  {\n    name: "New Photo",\n    path: "p/:id"\n  }\n]\n// when the user navigates to /photo/1:\n// response = { redirect: { pathname: "/p/1", ... } }'),r.a.createElement("p",null,"The ",r.a.createElement(l.f,null,"redirect")," property can also be used to specify a redirect to an external location. An external redirect object has only one property: ",r.a.createElement(l.f,null,"exernalURL"),"."),r.a.createElement(l.d,null,'{\n  name: "Redirects",\n  path: "redirects",\n  respond() {\n    return {\n      redirect: {\n        externalURL: "https://example.com"\n      }\n    }\n  }\n}'),r.a.createElement("p",null,"Responses with an external redirect are always emitted, even when"," ",r.a.createElement(l.f,null,"invisibleRedirects")," is ",r.a.createElement(l.f,null,"true"),". The actual location changing is left to the application.")))),r.a.createElement(l.e,{meta:{title:"children",hash:"children"},tag:"h3"},r.a.createElement("p",null,"An optional array of route objects for creating nested routes."),r.a.createElement("p",null,"Any child routes will be matched relative to their parent route's"," ",r.a.createElement(l.f,null,"path"),". This means that if a parent route's ",r.a.createElement(l.f,null,"path")," ","string is ",r.a.createElement(l.f,null,'"one"')," and a child route's ",r.a.createElement(l.f,null,"path")," string is ",r.a.createElement(l.f,null,'"two"'),", the child will match a location whose pathname is"," ",r.a.createElement(l.f,null,"/one/two"),"."),r.a.createElement(l.d,null,"// '/a/Coloring+Book/All+Night' will be matched\n// by the \"Song\" route, with the params\n// { album: 'Coloring+Book', title: 'All+Night' }\n{\n  name: 'Album',\n  path: 'a/:album',\n  children: [\n    {\n      name: 'Song',\n      path: ':title'\n    }\n  ]\n}")),r.a.createElement(l.e,{meta:{title:"params",hash:"params"},tag:"h3"},r.a.createElement("p",null,"When ",r.a.createElement(l.f,null,"path-to-regexp")," matches paths, all parameters are extracted as strings. The ",r.a.createElement(l.f,null,"params")," object is used to specify functions to transform the extracted value."),r.a.createElement("p",null,"Properties of the ",r.a.createElement(l.f,null,"route.params")," object are the names of params to be parsed. The paired value should be a function that takes a string (the value from the ",r.a.createElement(l.f,null,"pathname"),") and returns a new value (transformed using the function you provide)."),r.a.createElement("p",null,"By default, each param is decoded using ",r.a.createElement(l.f,null,"decodeURIComponent"),". A param function can be used to leave the param in its encoded form or to parse an integer param into a number."),r.a.createElement(l.d,null,"const routes = prepareRoutes([\n  {\n    name: 'Number',\n    path: 'number/:num',\n    params: {\n      num: n => parseInt(n, 10)\n    }\n  }\n]);\n\n// when the user visits /number/1,\n// response.params will be { num: 1 }\n// instead of { num: \"1\" }"),r.a.createElement("p",null,"Unnamed params are referred to by their index in the ",r.a.createElement(l.f,null,"path"),"."),r.a.createElement(l.d,null,"const routes = prepareRoutes([\n  {\n    name: 'Not Found',\n    path: '(.*)',\n    params: {\n      // skip decoding the unmatched value\n      0: value => value\n    }\n  }\n]);")),r.a.createElement(l.e,{meta:{title:"pathOptions",hash:"pathOptions"},tag:"h3"},r.a.createElement("p",null,"An object for configuring how the"," ",r.a.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp"},r.a.createElement(l.f,null,"path-to-regexp"))," ","handles the ",r.a.createElement(l.f,null,"path"),"."),r.a.createElement(l.d,null,'{\n  name: "My Route",\n  path: "my/:item",\n  pathOptions: {\n    match: {\n      sensitive: false\n    },\n    compile: {\n      encode: (value, token) => value\n    }\n  }\n}'),r.a.createElement(l.e,{tag:"h4",meta:{title:"match",hash:"pathOptions-match"}},r.a.createElement("p",null,"Properties for parsing the ",r.a.createElement(l.f,null,"path")," into a regular expression."),r.a.createElement("p",null,"You can see the options and their default values in the"," ",r.a.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp#usage"},r.a.createElement(l.f,null,"path-to-regexp")," documentation"),"."),r.a.createElement(l.g,null,r.a.createElement("p",null,"If a route has a children array property, it will"," ",r.a.createElement("strong",null,"always")," have the ",r.a.createElement(l.f,null,"end")," path option set to"," ",r.a.createElement(l.f,null,"false"),"."))),r.a.createElement(l.e,{tag:"h4",meta:{title:"compile",hash:"pathOptions-compile"}},r.a.createElement("p",null,"For pathname generation, the options are passed through a"," ",r.a.createElement(l.f,null,"compile")," object. There is only one possible option, which is an ",r.a.createElement(l.f,null,"encode")," function for encoding params. The default"," ",r.a.createElement(l.f,null,"encode")," function encodes params using"," ",r.a.createElement(l.f,null,"encodeURIComponent"),"."))),r.a.createElement(l.e,{meta:{title:"extra",hash:"extra"},tag:"h3"},r.a.createElement("p",null,"If you have any additional properties that you want attached to a route, use the ",r.a.createElement(l.f,null,"extra")," property. You will be able to use"," ",r.a.createElement(l.f,null,"route.extra")," in any custom route interactions."),r.a.createElement(l.d,null,"const routes = prepareRoutes([\n  {\n    name: 'A Route',\n    path: 'a-route',\n    extra: {\n      transition: 'fade'\n    }\n  },\n  {\n    name: 'B Route',\n    path: 'b-route',\n    extra: {\n      enter: 'slide-right'\n    }\n  }\n]);")))}var O={title:"announce",hash:"announce"};function P(){return r.a.createElement(l.e,{meta:O},r.a.createElement("p",null,"The ",r.a.createElement(l.f,null,"announce")," side effect is used to announce navigation to screen readers. The announcement is done using an"," ",r.a.createElement("a",{href:"https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions"},"ARIA live region"),"."),r.a.createElement("p",null,"The side effect will create an element with a ",r.a.createElement(l.f,null,"aria-live")," ","attribute and add it to the DOM. This element will be styled to not be displayed on screen (but not actually hidden) so that only screen readers detect it."),r.a.createElement(l.j,null,r.a.createElement("p",null,"This side effect should only be used in the browser.")),r.a.createElement("p",null,"The ",r.a.createElement(l.f,null,"announce")," function takes a single argument, which is a function that receives the object emitted by the router and returns the string that should be set for the screen reader to read."),r.a.createElement("p",null,"The DOM element's ",r.a.createElement(l.f,null,"aria-live")," attribute will be"," ",r.a.createElement(l.f,null,'"assertive"')," by default, but you can use the side-effect factory's second argument to pass an alternative (i.e."," ",r.a.createElement(l.f,null,'"polite"'),")."),r.a.createElement(l.d,null,"import { createRouter, announce } from '@curi/router';\n\nconst announcer = announce(\n  ({ response }) => `Navigated to ${response.meta.title}`\n);\n\nconst politeAnnouncer = announce(\n  ({ response }) => `Navigated to ${response.meta.title}`,\n  \"polite\"\n);\n\nconst router = curi(history, routes, {\n  sideEffects: [announcer]\n});"))}var H={title:"scroll",hash:"scroll"};function S(){return r.a.createElement(l.e,{meta:H},r.a.createElement("p",null,"The ",r.a.createElement(l.f,null,"scroll")," side effect will scroll the page after a navigation."),r.a.createElement(l.j,null,r.a.createElement("p",null,"This side effect should only be used in the browser.")),r.a.createElement("p",null,"When Curi is running in a browser, it relies on the"," ",r.a.createElement("a",{href:"https://developer.mozilla.org/en-US/docs/Web/API/History_API"},"History API")," ","to change locations. Navigating using the History API does not trigger scrolling to the top of the page after navigation, so this side effect scrolls for you."),r.a.createElement("p",null,"Pop navigation, such as clicking the browser's back and forward buttons, will rely on the browser to correctly restore the scroll position."),r.a.createElement(l.d,null,'import { createRouter, scroll } from "@curi/router";\n\nconst router = createRouter(browser, routes, {\n  sideEffects: [scroll()]\n});'))}var C={title:"title",hash:"title"};function W(){return r.a.createElement(l.e,{meta:C},r.a.createElement("p",null,"The ",r.a.createElement(l.f,null,"title")," side effect will set the document's title."),r.a.createElement(l.j,null,r.a.createElement("p",null,"This side effect should only be used in the browser.")),r.a.createElement("p",null,"The function takes a single argument, which is a function that takes the object emitted by a router and returns the string to set as the title."),r.a.createElement(l.d,null,"import { createRouter, title } from '@curi/router';\n\nconst router = createRouter(history, routes, {\n  sideEffects: [\n    title(({ response }) => {\n      return `${response.meta.title} | My Site`;\n    })\n  ]\n});"),r.a.createElement("p",null,"The recommended approach for determining a title is to have routes set their ",r.a.createElement(l.f,null,"meta.title")," property in their ",r.a.createElement(l.f,null,"respond")," method."),r.a.createElement(l.d,null,'{\n  name: "About",\n  path: "about",\n  respond() {\n    return {\n      body: About,\n      meta: {\n        title: "About"\n      }\n    }\n  }\n}\n// when the About route matches, document.title = "About | My Site"'))}function N(e){return(N="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function U(e,t){for(var n=0;n<t.length;n++){var a=t[n];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function q(e,t){return!t||"object"!==N(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function _(e){return(_=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function F(e,t){return(F=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}var L=function(e){function t(){return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t),q(this,_(t).apply(this,arguments))}var n,a,o;return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&F(e,t)}(t,r.a.PureComponent),n=t,(a=[{key:"render",value:function(){return r.a.createElement(r.a.Fragment,null,r.a.createElement(l.b,null,r.a.createElement("p",null,"The ",r.a.createElement(l.f,null,"@curi/router")," package is used to create a router.")),r.a.createElement(l.a,null,r.a.createElement(x,null),r.a.createElement(R,null),r.a.createElement(P,null),r.a.createElement(S,null),r.a.createElement(W,null),r.a.createElement(I,null)))}}])&&U(n.prototype,a),o&&U(n,o),t}(),M=[{title:"Installation",hash:"installation"},{title:"About",hash:"about"},{title:"API",hash:"API",children:[j,w,O,H,C,k]}];n.d(t,"component",function(){return L}),n.d(t,"contents",function(){return M})}}]);