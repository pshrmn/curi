(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{66:function(e,t,a){"use strict";a.r(t),a.d(t,"default",function(){return i});var n=a(0),l=a.n(n),r=a(3),o=a(27),c={title:"Loading Route Data"};function i(){return l.a.createElement(l.a.Fragment,null,l.a.createElement("h1",null,c.title),l.a.createElement(o.c,null,l.a.createElement("p",null,"In the code splitting guide, we added a function that calls"," ",l.a.createElement(o.d,null,"import()")," to a route's ",l.a.createElement(o.d,null,"resolve")," object in order to dynamically load modules. We can do the same thing for other data.")),l.a.createElement(o.g,{title:"resolve",id:"resolve"},l.a.createElement(o.c,null,l.a.createElement("p",null,"An async function (with any name you want it to have) can be added to the ",l.a.createElement(o.d,null,"resolve")," object and the value it resolves will be available in the route's ",l.a.createElement(o.d,null,"response()")," function (as a property of the ",l.a.createElement(o.d,null,"resolved")," object)."),l.a.createElement("p",null,"When the ",l.a.createElement(o.d,null,"Recipe")," route matches, we want to fetch data for that specific recipe (using the ",l.a.createElement(o.d,null,"id")," param from the path).")),l.a.createElement(o.b,null,"const routes = prepareRoutes([\n  {\n    name: 'Recipe',\n    path: 'recipe/:id'\n  }\n]);"),l.a.createElement(o.c,null,l.a.createElement("p",null,"Here, we will name the ",l.a.createElement(o.d,null,"resolve")," function for fetching data"," ",l.a.createElement(o.d,null,'"data"'),"."),l.a.createElement("p",null,"The ",l.a.createElement(o.d,null,"resolve.data()")," function will be passed an object that contains the matched route response properties, including the route"," ",l.a.createElement(o.d,null,"params"),"."),l.a.createElement("p",null,"All ",l.a.createElement(o.d,null,"resolve")," functions are expected to return a Promise."),l.a.createElement("p",null,"Now, when we navigate to ",l.a.createElement(o.d,null,"/recipe/cookies"),", the"," ",l.a.createElement(o.d,null,"resolve.data()")," function will call the fake API function to load the ",l.a.createElement(o.d,null,'"cookies"')," recipe. The function will resolve with the loaded data.")),l.a.createElement(o.b,null,"{\n  name: 'Recipe',\n  path: 'recipe/:id',\n  resolve: {\n    data: ({ params }) => fakeAPI.getRecipe(params.id)\n  }\n}")),l.a.createElement(o.g,{title:"response",id:"response"},l.a.createElement(o.c,null,l.a.createElement("p",null,"While ",l.a.createElement(o.d,null,"resolve.data()")," starts our data loading, it doesn't actually do anything. Instead, we should handle any loaded data with the ",l.a.createElement(o.d,null,"response()")," function."),l.a.createElement("p",null,"The ",l.a.createElement(o.d,null,"response()")," and ",l.a.createElement(o.d,null,"resolve.data()")," are separate because while a route is resolving, the user may navigate again, which overrides the current navigation. We cannot cancel the"," ",l.a.createElement(o.d,null,"resolve.data()")," function for the current navigation, so if it performs any side effects, our application is stuck with them. To avoid this, the ",l.a.createElement(o.d,null,"response()")," function is not called until we know that the current navigation will complete."),l.a.createElement("p",null,"The ",l.a.createElement(o.d,null,"response()")," function will receive an object with a number of properties. These are covered in in the"," ",l.a.createElement(r.b,{name:"Guide",params:{slug:"routes-and-responses"},hash:"route-response"},"Routes and Responses")," ","guide, but the only one we care about right now is"," ",l.a.createElement(o.d,null,"resolved"),".")),l.a.createElement(o.b,null,"{\n  name: 'Recipe',\n  path: 'recipe/:id',\n  resolve: {\n    data: ({ params }) => fakeAPI.getRecipe(params.id),\n  },\n  response({ resolved }) {\n    return {\n      body: Recipe,\n      data: resolved.data\n    }\n  }\n}"),l.a.createElement(o.c,null,l.a.createElement("p",null,"If at some point in time we decide that we want to change our URI pathname structure, we can also use the ",l.a.createElement(o.d,null,"response()")," ","function to redirect."),l.a.createElement("p",null,"You can specify the route to redirect to with ",l.a.createElement(o.d,null,"redirectTo"),". This takes the ",l.a.createElement(o.d,null,"name")," of the route to redirect to,"," ",l.a.createElement(o.d,null,"params")," if the route (or ancestor routes) have route params. ",l.a.createElement(o.d,null,"hash"),", ",l.a.createElement(o.d,null,"query"),", and ",l.a.createElement(o.d,null,"state")," can also be provided."),l.a.createElement("p",null,"After Curi emits the response, it will also automatically redirect to the new location!")),l.a.createElement(o.b,null,"{\n  name: 'Old Recipe',\n  path: 'r/:id',\n  response: ({ params }) => {\n    // destructure the current location to preserve\n    // query/hash values\n    return {\n      redirectTo: {\n        name: 'Recipe',\n        params: params,\n        hash: location.hash\n      }\n    };\n  }\n}")),l.a.createElement("p",null,"A route's ",l.a.createElement(o.d,null,"resolve")," object and ",l.a.createElement(o.d,null,"response()")," functions offer a convenient way to do data loading prior to actually rendering the route, but please remember that your application will not be re-rendering until ",l.a.createElement("em",null,"after")," the fetching has resolved. If you have a long running load function, you may wish to implement some sort of loading display. The"," ",l.a.createElement(r.b,{name:"Example",params:{category:"react",slug:"data-loading"}},"data loading example")," ","shows one approach to how to do this."))}}}]);