webpackJsonp([2],{55:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=a(n(78)),o=function(e){var t=e.params,n=e.data;if(!n)return l.default.createElement("div",null,"The requested guide could not be found.");var a=r.default[t.slug];return l.default.createElement(a,{name:n.name})};t.default=o},60:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=a(n(80)),o=function(e){var t=e.children;return l.default.createElement("div",{className:"guide"},l.default.createElement("div",{className:"content"},t||null),l.default.createElement("div",{className:"sidebar"},l.default.createElement("h2",null,"Guides"),l.default.createElement(r.default,null)))};t.default=o},78:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(79)),r=a(n(81)),o=a(n(82)),i=a(n(83)),u=a(n(84)),s=a(n(85)),c=a(n(86)),d=a(n(87)),h=a(n(88)),m=a(n(89)),p=a(n(90)),f=a(n(91)),E=a(n(92)),y=a(n(93)),g={installation:l.default,"getting-started":r.default,routes:o.default,"response-handlers":i.default,responses:u.default,"navigation-objects":s.default,addons:c.default,"side-effects":d.default,"response-caching":h.default,"code-splitting":m.default,loading:p.default,react:f.default,"react-native":E.default,"migrate-rrv3":y.default};t.default=g},79:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=n(1),o=a(n(60)),i=n(3),u=n(8),s=function(e){var t=e.name;return l.default.createElement(o.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"You can install the latest version of Curi from NPM. Curi has a peer dependency on the Hickory package, so you should go ahead and install that as well."),l.default.createElement(i.PrismBlock,{lang:"bash"},"npm install @hickory/browser @curi/core"),l.default.createElement("p",null,"If you prefer to use script tags, you can use"," ",l.default.createElement("a",{href:"https://unpkg.com"},"Unpkg")," to load Curi and Hickory."),l.default.createElement(i.PrismBlock,{lang:"markup"},'<script src="https://unpkg.com/@hickory/browser/dist/hickory-browser.min.js" />\n<script src="https://unpkg.com/@curi/core/dist/curi.min.js" />'),l.default.createElement(u.Section,{title:"Promises",id:"promises"},l.default.createElement("p",null,"Curi uses Promises, so you may need to include a polyfill to add Promise support for older browsers (including IE 11)."),l.default.createElement("p",null,"If you need a general ES2015 polyfill, you can check out the one provided by Babel's"," ",l.default.createElement("a",{href:"https://babeljs.io/docs/usage/polyfill/#usage-in-browser"},"babel-polyfill")," ","package. If you only need a Promise polyfill, then you should check out the"," ",l.default.createElement("a",{href:"https://github.com/stefanpenner/es6-promise"},"es6-promise")," ","package.")),l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,l.default.createElement(r.Link,{to:"Guide",params:{slug:"getting-started"}},"Get started")," ","with Curi."))};t.default=s},80:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=n(1),o=n(16),i=a(n(4)),u=function(e){var t=e.guides,n=e.withDescription;return l.default.createElement("ul",{className:"link-list"},t.map(function(e){return l.default.createElement("li",{key:e.name,className:n?"with":"solo"},l.default.createElement(r.Link,{to:"Guide",params:{slug:e.slug},active:{merge:i.default}},e.name))}))},s=function(e){var t=e.withDescription,n=void 0!==t&&t;return l.default.createElement("ul",null,Object.keys(o.groupedGuides).map(function(e){return l.default.createElement("li",{className:"link-group",key:e},l.default.createElement("h3",null,e),l.default.createElement(u,{guides:o.groupedGuides[e],withDescription:n}))}))};t.default=s},81:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=n(1),o=a(n(60)),i=n(3),u=n(8),s=n(9),c=function(e){var t=e.name;return l.default.createElement(o.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"This guide will cover a few basic concepts about Curi so that you can be confident integrating Curi into your application."),l.default.createElement(u.Section,{title:"The router",id:"router-object"},l.default.createElement("p",null,"A Curi router is created using a ",l.default.createElement(i.InlineJS,null,"history")," object and a"," ",l.default.createElement(i.InlineJS,null,"routes")," array. You create the router by calling the"," ",l.default.createElement(i.InlineJS,null,"curi")," function, which is the default export from the"," ",l.default.createElement(i.InlineJS,null,"@curi/core")," package."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"npm install @curi/core\n        \nimport curi from '@curi/core';\nimport Browser from '@hickory/browser';\nimport routes from './routes';\n\nconst history = Browser();\nconst router = curi(history, routes);\n"),l.default.createElement(s.Note,null,"This function also accepts an ",l.default.createElement(i.InlineJS,null,"options")," object. You can read about its properties in the"," ",l.default.createElement(r.Link,{to:"Package",params:{package:"core"},details:{hash:"options"}},l.default.createElement(i.InlineJS,null,"@curi/core"))," ","documentation.")),l.default.createElement(u.Section,{title:"The History Object",id:"history-object"},l.default.createElement("p",null,"The most important function of a router is to keep track of locations. Curi does this using ",l.default.createElement(i.InlineJS,null,"history")," objects created by your choice of one of the ",l.default.createElement("a",{href:"https://github.com/pshrmn/hickory"},"Hickory")," ","packages. Which Hickory package you choose depends mostly on where your application will be running."),l.default.createElement(u.Subsection,{title:"Browser",id:"hickory-browser"},l.default.createElement("p",null,"If you are building a website that will be hosted on a dynamic server (it can respond to requests for any location), you should use the"," ",l.default.createElement(i.InlineJS,null,"@hickory/browser")," package."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"npm install @hickory/browser\n          \nimport Browser from '@hickory/browser';\nconst browserHistory = Browser();")),l.default.createElement(u.Subsection,{title:"Hash",id:"hickory-hash"},l.default.createElement("p",null,"If you are building a website that will be hosted on a static file server, you will need to use the ",l.default.createElement(i.InlineJS,null,"@hickory/hash")," package. The paths for your routes will be encoded in the ",l.default.createElement(i.InlineJS,null,"hash"),' section of the URL. This isn\'t as "pretty" as the paths you get with'," ",l.default.createElement(i.InlineJS,null,"@hickory/browser"),", but is a necessary solution for statically hosted websites."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"npm install @hickory/hash\n          \nimport Hash from '@hickory/hash';\nconst hashHistory = Hash();")),l.default.createElement(u.Subsection,{title:"In Memory",id:"hickory-in-memory"},l.default.createElement("p",null,"If your application is not running in a browser, you should use an in-memory history. This is what you would use when building a mobile application with React Native, writing a NodeJS backend for your server, or when writing tests that run in NodeJS."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"npm install @hickory/in-memory\n\nimport InMemory from '@hickory/in-memory';\nconst memoryHistory = InMemory();")),l.default.createElement(u.Subsection,{title:"Properties and Methods",id:"props-and-methods"},l.default.createElement("p",null,"Each history object has essentially the same API (",l.default.createElement(i.InlineJS,null,"InMemory")," ","has a few extra properties). The most important properties to know are the ",l.default.createElement(i.InlineJS,null,"location")," object as well as the ",l.default.createElement(i.InlineJS,null,"navigate"),","," ",l.default.createElement(i.InlineJS,null,"push"),", and ",l.default.createElement(i.InlineJS,null,"replace")," methods."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"// the location property is the current location object\nbrowserHistory.location === {\n  pathname: '/guides/getting-started',\n  ...\n};\n\n// the push method will navigate to a new location\nbrowserHistory.push({\n  pathname: '/guides/installation'\n});\n\n// the replace method will replace the current location\n// with the provided one\nbrowserHistory.replace({\n  pathname: '/guides/confirming-navigation'\n});\n\n// the navigate method will choose whether to push or replace for you\n// this behavior mimics how anchors (<a>) navigate\nbrowserHistory.navigate({\n  pathname: '/guides/getting-started'\n});"))),l.default.createElement(u.Section,{title:"The Routes Array",id:"routes-array"},l.default.createElement("p",null,"Routes are objects with two required properties: a ",l.default.createElement(i.InlineJS,null,"name")," ","string and a ",l.default.createElement(i.InlineJS,null,"path")," string."),l.default.createElement(s.Note,null,"Paths can be any valid"," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp"},"path-to-regexp")," ","string. It is just important that you do not begin the string with a forward slash (/). Forward slashes are fine anywhere else in the path. (",l.default.createElement(i.InlineJS,null,"this/is/fine"),", but ",l.default.createElement(i.InlineJS,null,"/this/is/not"),")."),l.default.createElement("p",null,"Route names are used to generate pathnames for you. With Curi, you never have to write a pathname string yourself. This also means that all routes must have unique names."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    name: 'Home',\n    path: '', // matches the pathname /\n    ...\n  },\n  ...\n]"),l.default.createElement("p",null,"How route matching works and the other route properties are explained more in-depth in the"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"routes"}},"All About Routes")," ","guide.")),l.default.createElement(u.Section,{title:"Responses"},l.default.createElement("p",null,"Whenever navigation happens, Curi will create a ",l.default.createElement(i.InlineJS,null,"response")," ","object, which provides data based on the route that it matched. The router's ",l.default.createElement(i.InlineJS,null,"respond")," method is used to register callback functions (called response handlers), which the router will call when a new response is created."),l.default.createElement("p",null,"Response handlers will be passed an object with three properties:"," ",l.default.createElement(i.InlineJS,null,"response"),", ",l.default.createElement(i.InlineJS,null,"navigation"),", and ",l.default.createElement(i.InlineJS,null,"router"),"."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"function responseHandler(({ response, navigation, router }) {\n  // response - contains data about the matching route\n  // navigation - contains data about the location change\n  // router - your router, useful if you want to define this\n  //   in a separate module \n});"),l.default.createElement("p",null,"There are two types of response handlers, one time functions and observers."),l.default.createElement("p",null,"One time functions will be called one time, either immediately if a response already exist, or once the router's initial ",l.default.createElement(i.InlineJS,null,"response")," ","is created. These are useful for setup functions in your application."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"router.respond(() => {\n  // I will only be called once\n});"),l.default.createElement("p",null,"Observers will be called every time a response is created. These are great for triggering re-renders, although the render packages (",l.default.createElement(r.Link,{to:"Package",params:{package:"react"}},l.default.createElement(i.InlineJS,null,"@curi/react")),","," ",l.default.createElement(r.Link,{to:"Package",params:{package:"react-native"}},l.default.createElement(i.InlineJS,null,"@curi/react-native")),","," ",l.default.createElement(r.Link,{to:"Package",params:{package:"vue"}},l.default.createElement(i.InlineJS,null,"@curi/vue")),", and"," ",l.default.createElement(r.Link,{to:"Package",params:{package:"svelte"}},l.default.createElement(i.InlineJS,null,"@curi/svelte")),") handle this for you, so you likely won't need to use these manually."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const stopObserving = router.respond(() => {\n  // I will be called for every new response until the\n  // stopObserving function is called\n}, { observe: true });")),l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Rendering your application will be centered around these response objects. The"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"responses"}},"Response Handlers")," ","guide will go into more detail about their properties, but first we should take a look at how to write routes with the"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"routes"}},"All About Routes")," ","guide."))};t.default=c},82:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=n(1),o=a(n(60)),i=n(3),u=n(9),s=n(8),c=function(e){var t=e.name;return l.default.createElement(o.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"Routes are JavaScript objects with two required props: ",l.default.createElement(i.InlineJS,null,"name")," and"," ",l.default.createElement(i.InlineJS,null,"path"),". There are also a number of other props that you can use to enhance the routes, which are covered below."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"{\n  name: 'Home',\n  path: ''\n};"),l.default.createElement(s.Section,{title:"Route properties",id:"route-properties"},l.default.createElement(s.Subsection,{title:"name",id:"name"},l.default.createElement("p",null,"A string, this must be unique for every route."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"[\n  { name: 'Home' },\n  { name: 'Album' },\n  { name: 'Not Found' }\n];")),l.default.createElement(s.Subsection,{title:"path",id:"path"},l.default.createElement("p",null,"A string that will be passed to"," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp#parameters"},l.default.createElement(i.InlineJS,null,"path-to-regexp"))," ","to generate a regular expression use for matching the route to a location's ",l.default.createElement(i.InlineJS,null,"pathname"),"."," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp#parameters"},"Path parameters")," ","will be captured so that they can be parsed from a location's"," ",l.default.createElement(i.InlineJS,null,"pathname")," when the route matches."),l.default.createElement("p",null,l.default.createElement(i.InlineJS,null,"path")," strings should ",l.default.createElement("strong",null,"not")," have a leading slash"),l.default.createElement(i.PrismBlock,{lang:"javascript"},"[\n  { name: 'Home', path: '' },\n  { name: 'Album', path: 'a/:albumID' },\n  { name: 'Not Found', path: '(.*)' }\n];\n// don't do this\n// { name: 'Home', path: '/' }"),l.default.createElement(u.Note,null,l.default.createElement(i.InlineJS,null,"path-to-regexp")," supports arrays and RegExps, but only string paths are supported here. This is because the path must also be reversible to create a location's pathname given the name of a route and its params.")),l.default.createElement(s.Subsection,{title:"match",id:"match"},l.default.createElement("p",null,"The ",l.default.createElement(i.InlineJS,null,"match")," object used to provide functions that will be called when the route matches."),l.default.createElement("p",null,"While not required, you will almost always want to have a"," ",l.default.createElement(i.InlineJS,null,"match.response")," property on your routes."),l.default.createElement(s.Subsection,{tag:"h5",title:"initial",id:"initial"},l.default.createElement("p",null,"A function that returns a Promise. It will be called the first time that a route matches."),l.default.createElement("p",null,"This can be used for loading resources that are required for the route to display properly, but don't change based on"," ",l.default.createElement(i.InlineJS,null,"params"),". For example, if you are doing code splitting with Webpack using ",l.default.createElement(i.InlineJS,null,"import()"),", you can load the modules in"," ",l.default.createElement(i.InlineJS,null,"initial"),"."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const about = {\n  name: 'About',\n  path: 'about',\n  match: {\n    initial: () => import('./components/About')\n  }\n};")),l.default.createElement(s.Subsection,{tag:"h5",title:"every",id:"every"},l.default.createElement("p",null,"A function that will be called every time a route matches. This can be useful for data fetching. The ",l.default.createElement(i.InlineJS,null,"every"),' function will be passed the a "route" object containing the ',l.default.createElement(i.InlineJS,null,"params")," parsed from the location's pathname (using the route and its ancestor's paths), the current ",l.default.createElement(i.InlineJS,null,"location"),", and the ",l.default.createElement(i.InlineJS,null,"name")," of the matched route."),l.default.createElement("p",null,"Like ",l.default.createElement(i.InlineJS,null,"initial"),", ",l.default.createElement(i.InlineJS,null,"every")," must return a Promise."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"// fetch user data\nconst user = {\n  name: 'User',\n  path: ':id',\n  match: {\n    every: ({ params, location }) =>\n      fetch(`/api/users/${params.id}`)\n        .then(resp => JSON.parse(resp))\n  }\n}"),l.default.createElement(u.Note,null,"You should not perform side effects (e.g. passing the loaded data to a Redux store) in ",l.default.createElement(i.InlineJS,null,"every")," because it is possible that navigating to the route might be cancelled. If you must perform side effects, you should do so in ",l.default.createElement(i.InlineJS,null,"match.response"),".")),l.default.createElement(s.Subsection,{tag:"h5",title:"response",id:"response"},l.default.createElement("p",null,"A function that will be called right before a response is emitted. This function is where you can set various properties of the"," ",l.default.createElement(i.InlineJS,null,"response")," object. The ",l.default.createElement(i.InlineJS,null,"response")," function will be passed an object with a number of properties."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"response: ({ error, resolved, route, set, addons }) => {\n  // ...\n}"),l.default.createElement("ul",null,l.default.createElement(s.Subsection,{tag:"li",title:"error",id:"response-error"},l.default.createElement("p",null,"If either the ",l.default.createElement(i.InlineJS,null,"initial")," or ",l.default.createElement(i.InlineJS,null,"every")," functions reject with an error, that error will be passed to the"," ",l.default.createElement(i.InlineJS,null,"response")," function."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"// check if there was an error in every or initial\nconst user = {\n  name: 'User',\n  path: ':id',\n  match: {\n    every: ({ params, location }) => {\n      return Promise.reject('Nope!')\n    },\n    response: ({ error, set }) => {\n      if (error) {\n        set.error(error);\n      }\n    }\n  }\n};")),l.default.createElement(s.Subsection,{tag:"li",title:"resolved",id:"response-resolved"},l.default.createElement("p",null,l.default.createElement(i.InlineJS,null,"resolved")," is an object with the values resolved by the"," ",l.default.createElement(i.InlineJS,null,"initial")," and ",l.default.createElement(i.InlineJS,null,"every")," functions (or"," ",l.default.createElement(i.InlineJS,null,"null")," if the router has neither an ",l.default.createElement(i.InlineJS,null,"initial")," ","function nor an ",l.default.createElement(i.InlineJS,null,"every")," function. If the route has one, but not the other, the missing value will be"," ",l.default.createElement(i.InlineJS,null,"undefined")," on the ",l.default.createElement(i.InlineJS,null,"resolved")," object."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"// attach resolved data to the response\nconst user = {\n  name: 'User',\n  path: ':id',\n  match: {\n    every: ({ params, location }) => (\n      fetch(`/api/users/${params.id}`)\n        .then(resp => JSON.parse(resp))\n    ),\n    response: ({ resolved, set }) => {\n      set.data(resolved.every);\n    }\n  }\n}")),l.default.createElement(s.Subsection,{tag:"li",title:"route",id:"response-route"},l.default.createElement("p",null,"This is the same object that is passed to the ",l.default.createElement(i.InlineJS,null,"every")," ","function and contains three properties: the parsed"," ",l.default.createElement(i.InlineJS,null,"params"),", the ",l.default.createElement(i.InlineJS,null,"location"),", and the"," ",l.default.createElement(i.InlineJS,null,"name")," of the matched route.")),l.default.createElement(s.Subsection,{tag:"li",title:"set",id:"response-set"},l.default.createElement("p",null,"The ",l.default.createElement(i.InlineJS,null,"set")," object contains a number of functions that you can use to modify the response."),l.default.createElement("ul",null,l.default.createElement("li",null,l.default.createElement(i.InlineJS,null,"body(body)")," - The value passed to this method will be set as the response's ",l.default.createElement(i.InlineJS,null,"body")," property."),l.default.createElement("li",null,l.default.createElement(i.InlineJS,null,"data(data)")," - The value passed to this method will be set as the response's ",l.default.createElement(i.InlineJS,null,"data")," property."),l.default.createElement("li",null,l.default.createElement(i.InlineJS,null,"redirect({ name, status, ... })")," - This allows you to turn the response into a redirect response. When you application receives a redirect response, it should redirect to the new location (using your history object) instead of re-rendering. If you do not provide a code, then 301 will be used. Setting the status code is mostly important for rendering on the server. The ",l.default.createElement(i.InlineJS,null,"to")," argument should be a string or a location object. Once the response has been created, Curi will automatically redirect to the ",l.default.createElement(i.InlineJS,null,"to")," ","location."),l.default.createElement("li",null,l.default.createElement(i.InlineJS,null,"error(error)")," - A method to call when something goes wrong. This will add an error property to the response."),l.default.createElement("li",null,l.default.createElement(i.InlineJS,null,"status(code)")," - This method will set a new status for the response (the default status is 200 when a route matches and 404 when no routes match)."),l.default.createElement("li",null,l.default.createElement(i.InlineJS,null,"title(t)")," - This method will set the"," ",l.default.createElement(i.InlineJS,null,"title")," property of the response, which is used by"," ",l.default.createElement(i.InlineJS,null,"@curi/side-effect-title")," to set the document's title.")),l.default.createElement(i.PrismBlock,{lang:"javascript"},"// when the user visits /contact, the response object's body\n// property will be the Contact value\nimport Contact from './components/Contact';\n\nconst routes = [\n  {\n    name: 'Contact',\n    path: 'contact',\n    match: {\n      response: ({ set }) => {\n        set.body(Contact);\n      }\n    }\n  }\n];")),l.default.createElement(s.Subsection,{tag:"li",title:"addons",id:"response-addons"},l.default.createElement("p",null,"The add-ons that have been registered with Curi are available to the ",l.default.createElement(i.InlineJS,null,"response")," function."))))),l.default.createElement(s.Subsection,{title:"children",id:"children"},l.default.createElement("p",null,"An optional array of route objects for creating nested routes. Any child routes will be matched relative to their parent route's"," ",l.default.createElement(i.InlineJS,null,"path"),". This means that if a parent route's ",l.default.createElement(i.InlineJS,null,"path")," ","string is ",l.default.createElement(i.InlineJS,null,"'one'")," and a child route's ",l.default.createElement(i.InlineJS,null,"path")," string is ",l.default.createElement(i.InlineJS,null,"'two'"),", the child will match when the pathname is"," ",l.default.createElement(i.InlineJS,null,"'one/two'"),"."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"// '/a/Coloring+Book/All+Night' will be matched\n// by the \"Song\" route, with the params\n// { album: 'Coloring+Book', title: 'All+Night' }\n{\n  name: 'Album',\n  path: 'a/:album',\n  children: [\n    {\n      name: 'Song',\n      path: ':title'\n    }\n  ]\n}")),l.default.createElement(s.Subsection,{title:"params",id:"params"},l.default.createElement("p",null,"When ",l.default.createElement(i.InlineJS,null,"path-to-regexp")," matches your paths, all parameters are extracted as strings. However, you might prefer for some route params to be other types. You can provide functions to transform params using the ",l.default.createElement(i.InlineJS,null,"route.params")," object."),l.default.createElement("p",null,"Properties of the ",l.default.createElement(i.InlineJS,null,"route.params")," object are the names of params to be parsed. The paired value should be a function that takes a string (the value from the ",l.default.createElement(i.InlineJS,null,"pathname"),") and returns a new value (transformed however you want)."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    name: 'Number',\n    path: 'number/:num',\n    params: {\n      num: n => parseInt(n, 10)\n    }\n  }\n]\n// when the user visits /number/1,\n// response.params will be { num: 1 } instead of { num: \"1\" }")),l.default.createElement(s.Subsection,{title:"pathOptions",id:"pathOptions"},l.default.createElement("p",null,"If you need to provide different path options than"," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp#usage"},"the defaults")," ","used by ",l.default.createElement(i.InlineJS,null,"path-to-regexp"),", you can provide them with a"," ",l.default.createElement(i.InlineJS,null,"pathOptions")," object."),l.default.createElement(u.Note,null,"If a route has a children array property, it will"," ",l.default.createElement("strong",null,"always")," have the ",l.default.createElement(i.InlineJS,null,"end")," path option set to false.")),l.default.createElement(s.Subsection,{title:"extra",id:"extra"},l.default.createElement("p",null,"If you have any additional properties that you want attached to a route, use the ",l.default.createElement(i.InlineJS,null,"extra")," property. You will be able to use"," ",l.default.createElement(i.InlineJS,null,"route.extra")," in any custom add-ons."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    name: 'A Route',\n    path: 'a-route',\n    extra: {\n      transition: 'fade'\n    }\n  },\n  {\n    name: 'B Route',\n    path: 'b-route',\n    extra: {\n      enter: 'slide-right'\n    }\n  }\n];"))),l.default.createElement(s.Section,{title:"Matching Routes",id:"matching-routes"},l.default.createElement("p",null,"Whenever Curi receives a new location, it will determine which route has a ",l.default.createElement(i.InlineJS,null,"path")," that matches the new location's ",l.default.createElement(i.InlineJS,null,"pathname")," by walking over the route objects in the order that they are defined in the array. If a route has ",l.default.createElement(i.InlineJS,null,"children"),", those will be checked before moving to the route's nest sibling."),l.default.createElement("p",null,"We'll use this simple route setup to demonstrate how this works."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    name: 'Home',\n    path: '',\n  },\n  {\n    name: 'Album',\n    path: 'a/:album'\n  },\n  {\n    name: 'Not Found',\n    path: '(.*)' // this matches EVERY pathname\n  }\n];"),l.default.createElement("p",null,"Curi's default matching behavior looks for exact matches. This means that when the route only matches part of the pathname, it does not count as a match. If the user navigates to a location with the pathname"," ",l.default.createElement(i.InlineJS,null,'"/a/red/yellow"'),", the ",l.default.createElement(i.InlineJS,null,"Album")," route will only partially match, so Curi will move on to the next route,"," ",l.default.createElement(i.InlineJS,null,"Not Found"),", which has a catch all ",l.default.createElement(i.InlineJS,null,"path")," that matches every pathname."),l.default.createElement("p",null,"However, if a route has children, then Curi will check if any of those routes form a complete match before moving on to the next route in the routes array."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"// when the pathname is '/a/Coloring+Book/All+Night',\n// the Album route will partially match the pathname. Then,\n// its child route Song will be tested and fully match the pathname.\n{\n  name: 'Album',\n  path: 'a/:album',\n  children: [\n    {\n      name: 'Song',\n      path: ':title'\n    }\n  ]\n}"),l.default.createElement("p",null,"You can control whether a route does exact or partial matching with"," ",l.default.createElement(r.Link,{details:{hash:"pathOptions"}},l.default.createElement(i.InlineJS,null,"pathOptions"))," ","property. If you set ",l.default.createElement(i.InlineJS,null,"{ end: false }"),", a route that partially matches will consider itself matched."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"// when the pathname is '/a/Good+Kid,+M.A.A.D+City/Poetic+Justice',\n// the Album route will partially match. However, because it sets\n// end to false, the partial match will be used.\n{\n  name: 'Album',\n  path: 'a/:albumID',\n  pathOptions: {\n    end: false\n  }\n}"),l.default.createElement(s.Subsection,{title:"No Matching Route",id:"catch-all"},l.default.createElement("p",null,'If none of your routes match a pathname, then Curi will set a "404" status on the ',l.default.createElement(i.InlineJS,null,"response")," object. The ",l.default.createElement(i.InlineJS,null,"body")," property of the response will also be ",l.default.createElement(i.InlineJS,null,"undefined"),", so it is important that your application checks the response's status when it renders."),l.default.createElement("p",null,"A better option is to add a catch all route (",l.default.createElement(i.InlineJS,null,"path: '(.*)'"),') to the end of your routes array, and that route will always match. You may want to still manually set the status to "404" for the catch all route in the route\'s ',l.default.createElement(i.InlineJS,null,"match.response")," method, but it is not required."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"{\n  name: 'Not Found',\n  path: '(.*)',\n}"))),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Now that you know how to setup your routes, we will take a look at"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"response-handlers"}},"response handlers"),".")))};t.default=c},83:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=n(1),o=a(n(60)),i=n(3),u=n(9),s=n(8),c=function(e){var t=e.name;return l.default.createElement(o.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"Response handlers are functions that are called by the router when a new response is emitted."),l.default.createElement(s.Section,{title:"Response Handler Argument",id:"argument"},l.default.createElement("p",null,"Response handlers are passed an object with three properties:"," ",l.default.createElement(r.Link,{to:"Package",params:{package:"core"},details:{hash:"properties"}},l.default.createElement(i.InlineJS,null,"router")),","," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"responses"}},l.default.createElement(i.InlineJS,null,"response")),", and"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"navigation-objects"}},l.default.createElement(i.InlineJS,null,"navigation")),". Which one you will need will vary based on what the response handler is doing."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"function responseHandler({ router, response, navigation }) {\n  // ...\n}")),l.default.createElement(s.Section,{title:"Use Cases",id:"use-cases"},l.default.createElement(s.Subsection,{title:"Setup",id:"setup"},l.default.createElement("p",null,"Curi creates responses asynchronously, which means that when your application first renders, the initial response hasn't necessarily been created. To deal with this, you can use a response handler to perform any setup that needs the initial response to exist."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"function setup({ router }) {\n  ReactDOM.render((\n    <CuriProvider router={router}>\n      {({ response }) => <response.body />}\n    </CuriProvider>\n  ), document.getElementById('root'));\n}"),l.default.createElement("p",null,"A setup function only needs to be called once, so you can call"," ",l.default.createElement(i.InlineJS,null,"router.respond")," without any options."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"router.respond(setup);"),l.default.createElement(u.Note,null,"Setup is the only thing your application should need to write a response handler for. Some other use cases will be discussed below, but")),l.default.createElement(s.Subsection,{title:"A Render Function",id:"render-function"},l.default.createElement("p",null,"You could manually re-render your application by using a response handler that observes the router for every response (by passing the"," ",l.default.createElement(i.InlineJS,null,"{ observe: true }")," option to ",l.default.createElement(i.InlineJS,null,"router.respond"),")."),l.default.createElement("p",null,"If your application is using one of the provided Curi rendering packages (",l.default.createElement(r.Link,{to:"Package",params:{package:"react"}},l.default.createElement(i.InlineJS,null,"@curi/react")),","," ",l.default.createElement(r.Link,{to:"Package",params:{package:"react-native"}},l.default.createElement(i.InlineJS,null,"@curi/react-native")),","," ",l.default.createElement(r.Link,{to:"Package",params:{package:"vue"}},l.default.createElement(i.InlineJS,null,"@curi/vue")),", and"," ",l.default.createElement(r.Link,{to:"Package",params:{package:"svelte"}},l.default.createElement(i.InlineJS,null,"@curi/svelte")),") you won't actually have to manually observe the router because those packages do that internally for you."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"function render({ response }) {\n  // render somehow\n}\n\nrouter.respond(render, { observe: true });")),l.default.createElement(s.Subsection,{title:"Side Effects",id:"side-effects"},l.default.createElement("p",null,"Side effects are response handlers that are provided to the router at creation instead of by calling ",l.default.createElement(i.InlineJS,null,"router.respond"),". These can be useful for tasks that are not rendering related as well as for tasks that need to be performed after a render has completed."),l.default.createElement("p",null,"The"," ",l.default.createElement(r.Link,{to:"Package",params:{package:"side-effect-title"}},l.default.createElement(i.InlineJS,null,"@curi/side-effect-title"))," ","package provides a side effect that will use ",l.default.createElement(i.InlineJS,null,"response.title")," ","to set the page's ",l.default.createElement(i.InlineJS,null,"document.title"),"."),l.default.createElement("p",null,"With single-page applications, clicking on links wish hashes won't always scroll to the matching element in the page. The"," ",l.default.createElement(r.Link,{to:"Package",params:{package:"side-effect-scroll"}},l.default.createElement(i.InlineJS,null,"@curi/side-effect-scroll"))," ","package adds this behavior by scrolling the page to the element that matches the new response's hash (",l.default.createElement(i.InlineJS,null,"response.location.hash"),") after the new response has rendered."),l.default.createElement("p",null,"If you need to add logging to your application, you could write your own response handler to do this. Your response handler can either be added as a side effect when the router is constructed or later using"," ",l.default.createElement(i.InlineJS,null,"router.respond"),"."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"function logger({ response }) {\n  loggingAPI.add(response.location);\n}\n\n// as a side-effect\nconst router = curi(history, routes, {\n  sideEffects: [{ fn: logger }]\n});\n\n// with respond\nrouter.respond(logger, { observe: true });"))),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Next, we will cover"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"responses"}},"response objects"),".")))};t.default=c},84:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=n(1),o=a(n(60)),i=n(3),u=n(9),s=n(8),c=function(e){var t=e.name;return l.default.createElement(o.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"Response objects are created by the router to descibe the route that matches a location. Some of these properties are set automatically, while others can be configured using the ",l.default.createElement(i.InlineJS,null,"set")," functions in a route's"," ",l.default.createElement(i.InlineJS,null,"match.response")," method."),l.default.createElement(u.Note,null,"You can review the ",l.default.createElement(i.InlineJS,null,"set")," functions in the"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"routes"},details:{hash:"response-set"}},"routes guide"),"."),l.default.createElement(s.Section,{title:"The Properties of a Response Object",id:"response-properties"},l.default.createElement(i.PrismBlock,{lang:"javascript"},"{\n  // The location key\n  key: '1.0',\n\n  // The location object used to generate the response.\n  location: { pathname: '/photos/6789/12345', ... },\n\n  // The name of the best matching route\n  name: 'Photo',\n\n  // The name of ancestor routes that matched\n  // part of the location's pathname\n  partials: ['Album'],\n\n  // An object containing the values parsed\n  // from the pathname by path-to-regexp.\n  // This includes params from ancestor routes.\n  params: { photoID: 12345, albumID: 6789 },\n\n  // The status code for the response.\n  // This defaults to 200, but is 404 if no routes match.\n  // It can also be set with set.status and set.redirect\n  // in a route's match.response method.\n  status: 200,\n\n  // This can be anything you want. It is set using\n  // the set.data in a route's match.response method.\n  // The default value is undefined.\n  data: {...},\n\n  // The title string is set by calling set.title in\n  // match.response. The default value is an empty string.\n  title: 'Photo 12345',\n\n  // The value set using set.body. This is where you can attach\n  // component(s) to a route. The structure here is up to\n  // you, but each of your routes should have the same structure.\n  body: Photo,\n  // or maybe\n  body: {\n    menu: PhotoMenu,\n    main: Photo\n  },\n  // Please see below for more information about this property\n\n  // A value set by the match.response's set.error function\n  error: undefined\n}"),l.default.createElement(s.Subsection,{title:"Redirect Response",id:"redirect-properties"},l.default.createElement("p",null,"When you call"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"routes"},details:{hash:"response-set"}},l.default.createElement(i.InlineJS,null,"set.redirect"))," ","in ",l.default.createElement(i.InlineJS,null,"match.response"),", the response will have a"," ",l.default.createElement(i.InlineJS,null,"redirectTo")," property. Curi will automatically trigger a redirect when it sees this."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"{\n  // The redirectTo property provides information on\n  // where you should redirect to\n  redirectTo: { pathname: '/login' }\n}"),l.default.createElement("p",null,"You can choose whether or not you want redirect responses emitted to response handlers. The default behavior is that they are, but this also means that you have to render using the redirect response. You can pass the ",l.default.createElement(i.InlineJS,null,"{ emitRedirects: false }")," option when you create your router to prevent this."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const router = curi(history, routes, {\n  emitRedirects: false\n});"))),l.default.createElement(s.Section,{title:"The Body Property",id:"body-property"},l.default.createElement("p",null,"The body property of a response is likely the most important property of a ",l.default.createElement(i.InlineJS,null,"response")," because it is what you will actually render. It is the value set by the matched route's ",l.default.createElement(i.InlineJS,null,"match.response")," function, using"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"routes"},details:{hash:"response-set"}},l.default.createElement(i.InlineJS,null,"set.body()")),". This value can be anything you want it to be, but it should usually be a function/component or an object containing functions/components."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"{\n  ...,\n  match: {\n    response: ({ set }) => {\n      // a function/component\n      set.body(Home);\n      // an object containing\n      // functions/componnets\n      set.body({\n        menu: HomeMenu,\n        body: Home\n      });\n    }\n  }\n}"),l.default.createElement(u.Note,null,"It is important that each route uses the same structure for setting the body. Mixing structures will make renderin more difficult to reason about.")),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Next, we'll take a look at another object passed to response handlers:"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"navigation-objects"}},"navigation objects")," ",".")))};t.default=c},85:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=n(1),o=a(n(60)),i=n(3),u=(n(9),n(8)),s=function(e){var t=e.name;return l.default.createElement(o.default,null,l.default.createElement("h1",null,t),l.default.createElement(u.Section,{title:"The Properties of a Navigation Object",id:"navigation-properties"},l.default.createElement("p",null,"The ",l.default.createElement(i.InlineJS,null,"navigation")," object contains information about the previous navigation. It has two properties: ",l.default.createElement(i.InlineJS,null,"action")," and"," ",l.default.createElement(i.InlineJS,null,"previous"),"."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"{\n  // the type of navigation,\n  // either PUSH, REPLACE, or POP\n  action: 'PUSH',\n\n  // the previous response object\n  // or null for the initial response\n  previous: {\n    name: 'Home',\n    ...\n  }\n}")),l.default.createElement(u.Section,{title:"Usage",id:"usage"},l.default.createElement("p",null,"What is the point of the ",l.default.createElement(i.InlineJS,null,"navigation")," object? It is there to provide you information about a navigation that doesn't make sense to attach to a ",l.default.createElement(i.InlineJS,null,"response")," object."),l.default.createElement("p",null,"One usage of it would be to display a Pinterest/Twitter style modal. You could render the background using the previous response while rendering the modal using the new response."),l.default.createElement("p",null,"Another use case may be to determine how to transition between two locations, either using the ",l.default.createElement(i.InlineJS,null,"action")," to determine ",l.default.createElement("em",null,"how")," ","the application navigated or the ",l.default.createElement(i.InlineJS,null,"previous")," response to map between two routes.")),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Let's take a moment to go back to our router and look at what Curi's add-ons are for in the"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"addons"}},"Using Add-ons")," ","guide.")))};t.default=s},86:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=n(1),o=a(n(60)),i=n(3),u=n(8),s=function(e){var t=e.name;return l.default.createElement(o.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"Add-ons in Curi allow you to interact with a registered route using its name. A registered route is generally any route that is in the array of routes that you used to create your router. However, some add-ons only register routes that meet some criteria."),l.default.createElement("p",null,"Add-ons are objects with three properties: name, register, and get."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"{\n  // the string you will use to call the add-on\n  name: 'MyAddon',\n\n  // a function used internally to register routes\n  // with the add-on. You only need to use this when\n  // writing your own add-ons\n  register: function(route, parentData) {...},\n\n  // this is the function that will be added to your\n  // router object's add-ons property. For example, with\n  // this add-on, the get function will be called when\n  // you call router.addons.MyAddon('...')\n  get: function(route) {...},\n  reset: function() {...}\n}"),l.default.createElement("p",null,"However, when you import them, you are actually importing an add-on factory function. You need to call the function to create the add-on that you will pass to your Curi router."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"function myAddonFactory() {\n  return { name: ..., register: ..., get: ..., };\n}"),l.default.createElement(u.Section,{title:"Adding add-ons",id:"adding"},l.default.createElement("p",null,"As stated above, whenever you include add-ons in your router object, you do not pass the actual add-on object. Instead, you pass an add-on instance (multiple routers would each have their own instance of the add-on), which can be useful for server-side rendering."),l.default.createElement("p",null,"Addons are provided to the ",l.default.createElement(i.InlineJS,null,"curi")," call as an array using the addons property of the options object (the third argument to"," ",l.default.createElement(i.InlineJS,null,"curi"),")."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const router = curi(history, routes, {\n  addons: [createMyAddon()]\n});"),l.default.createElement("p",null,"The add-on will be added to the router's addons property. To call an add-on, you simply use its name."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const myValue = router.addons.myAddon('Some Route', ...);")),l.default.createElement(u.Section,{title:"Creating Addons",id:"creating"},l.default.createElement("p",null,"You may find yourself wanting to add a custom add-on to your application. There are just a few steps that you should follow in order to write your own add-on."),l.default.createElement("p",null,"Remember that you need to export a function that will create the add-on object, not the actual add-on object."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"export default function myAddonFactory() {\n  ...\n}"),l.default.createElement("p",null,"The function should return an object with four properties:"," ",l.default.createElement(i.InlineJS,null,"name"),", ",l.default.createElement(i.InlineJS,null,"register"),", ",l.default.createElement(i.InlineJS,null,"get"),", and"," ",l.default.createElement(i.InlineJS,null,"reset"),". name is a unique identifier for the add-on, register is a function that will be used for your add-on to store information about each route, get is a function that will receive a route's name (and possibly other arguments) and perform some task using the related route, and reset is a function that will reset the add-on's internal state (this is used if you call ",l.default.createElement(i.InlineJS,null,"router.refresh"),")."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"export default function myAddonFactory() {\n  let knownRoutes = {};\n  return {\n    name: 'MyFirstAddon',\n    register: route => {\n      knownRoutes[route.name] = true;\n    },\n    get: (name) => {\n      return knownRoutes[name] != null\n    },\n    reset: () => {\n      knownRoutes = {};\n    }\n  };\n}"),l.default.createElement("p",null,"That is all there is to creating a basic add-on. Now, you just need to make sure to pass it to your router and you will be able to call your add-on's get function from your router."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"import curi from '@curi/core';\nimport myAddonFactory from './myAddon'\n\nconst routes = [{ name: 'Home', path: '' }];\n\nconst router = curi(history, routes, {\n  addons: [myAddonFactory()]\n});\n\nrouter.addons.MyFirstAddon('Home'); // true\nrouter.addons.MyFirstAddon('Elsewhere'); // false"),l.default.createElement(u.Subsection,{title:"Slightly more advanced",id:"Slightly-more-advanced"},l.default.createElement("p",null,"You might want to write an add-on that uses data from parent routes when registering a route. For example, the built-in pathname add-on joins a route's path with it parent path(s)."),l.default.createElement("p",null,"If you want your add-on to provide similar functionality, all you have to do is have the register function return the data that should be passed to its child routes. Then, when any children of that route are registered, they will be passed the return value from their parent as the second argument of the register function."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"function ParentFactory() {\n  let routeTree = {};\n  return {\n    name: 'routeParent',\n    register: (route, parent) => {\n      // parent is the value returned by the route's parent route\n      // and will be undefined when a route does not have a parent\n      routeTree[route.name] = parent;\n      return route.name;\n    },\n    get: (name) => {\n      return routeTree[name];\n    },\n    reset: () => {\n      routeTree = {};\n    }\n  }\n}"))),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,"Next on the list are side effects, which you can learn more about in the"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"side-effects"}},"Using Side Effects")," ","guide.")))};t.default=s},87:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=n(1),o=a(n(60)),i=n(3),u=n(8),s=function(e){var t=e.name;return l.default.createElement(o.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"Curi side effects are essentially permament observers (response handlers) of your router, but you can specify whether they should be run before or after response handlers that were setup using ",l.default.createElement(i.InlineJS,null,"router.respond"),"."),l.default.createElement("p",null,"Whenever a new response is generated, all of the side effect functions will be called. They will be given two arguments: the new response object and an object with navigation information (the navigation action the previous response)."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"function logResponse({ response }) {\n  // call your logging API to record the response\n}"),l.default.createElement(u.Section,{title:"Adding Side Effects",id:"adding"},l.default.createElement("p",null,"You add side effect functions to your router by adding a"," ",l.default.createElement(i.InlineJS,null,"sideEffects")," array to the options object (the third agument) of ",l.default.createElement(i.InlineJS,null,"curi"),". A side effect is an object with an ",l.default.createElement(i.InlineJS,null,"fn")," ","property whose values is a response handler function."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const router = curi(history, routes, {\n  sideEffects: [{ fn: logResponse }]\n});"),l.default.createElement("p",null,"Side effects can also have an ",l.default.createElement(i.InlineJS,null,"after")," property. By default, side effect functions will be called before any response handler functions (the ones added with ",l.default.createElement(i.InlineJS,null,"router.respond"),"). However, you might prefer for a side effect to be run after the response handlers. To do that, you just need to include ",l.default.createElement(i.InlineJS,null,"after: true")," in your side effect object. If you do no provide this property, this will default to"," ",l.default.createElement(i.InlineJS,null,"false"),"."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const router = curi(history, routes, {\n  sideEffects: [{ fn: logResponse, after: true }]\n});"),l.default.createElement(u.Subsection,{title:"Official Side Effects",id:"official"},l.default.createElement("p",null,'Curi has two "official" side effect packages:'),l.default.createElement("ul",null,l.default.createElement("li",null,l.default.createElement(r.Link,{to:"Package",params:{package:"side-effect-title"}},"@curi/side-effect-title")),l.default.createElement("li",null,l.default.createElement(r.Link,{to:"Package",params:{package:"side-effect-scroll"}},"@curi/side-effect-scroll"))))),l.default.createElement(u.Section,{title:"Creating Side Effects",id:"creating"},l.default.createElement("p",null,"Side effects are just simple functions that receive a response object and a navigation object and do something with them. One thing that they should not do, however, is to modify the response."),l.default.createElement("p",null,"Below is a side effect function that sets a modified property on the object."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"function mySideEffect({ response, navigation }) {\n  console.log('Navigating to', response.location);\n  console.log('Navigation action:', navigation.action);\n}\n\nconst router = curi(history, routes, {\n  sideEffects: [{ fn: mySideEffect }]\n});"),l.default.createElement("p",null,"You can write a side effect factory if you need to create a more customizable side effect."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"function AnalyticsLogger(options) {\n  // do some setup with the provided options\n  const logger = setupMyLogger(options);\n\n  // and return the actual side effect function\n  return sideEffect({ response }) {\n    logger(response);\n  }\n}"),l.default.createElement("p",null,"That really is all there is required to know in order to write your own side effects. You may want to review the"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"responses"},details:{hash:"response-properties"}},"response properties")," ","to know which properties you should expect a response to have, but other than that they are pretty simple.")),l.default.createElement("div",null,l.default.createElement("h2",null,"Next"),l.default.createElement("p",null,l.default.createElement(i.InlineJS,null,"curi"),"'s options object has three arguments. We have covered the first two, so finally we will cover the cache option in the"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"response-caching"}},"response caching")," ","guide.")))};t.default=s},88:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=(n(1),a(n(60))),o=n(3),i=(n(8),function(e){var t=e.name;return l.default.createElement(r.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"The cache option passed to ",l.default.createElement(o.InlineJS,null,"curi")," allows you to save response objects. The actual caching mechanism is left up to you. It only has two requirements:"),l.default.createElement("ul",null,l.default.createElement("li",null,"It provides a set function which receives a response object as its argument."),l.default.createElement("li",null,"It provides a get function which receives a location object as its argument and returns a response object associated with the location (if one exists)")),l.default.createElement(o.PrismBlock,{lang:"javascript"},"const createSimpleCache = () => {\n  const cache = {};\n\n  return {\n    get: location => {\n      const { key } = location;\n      return cache[key];\n    },\n    set: response => {\n      const { key } = response.location;\n      cache[key] = response;\n    }\n  };\n}\n\nconst myCache = createSimpleCache();\n\nconst router = curi(history, routes, {\n  cache: myCache\n});"),l.default.createElement("p",null,"The above cache uses a location's key property to store values."),l.default.createElement("p",null,"So why would you want to use a cache? When the user uses the browser's forward/back buttons, Curi will generate a new response. This means that if the route has a ",l.default.createElement(o.InlineJS,null,"match.every")," function, it will be re-called. You can mitigate this by adding a cache to that function, but you may also find it preferable to just re-use the existing response."),l.default.createElement("p",null,"This isn't built-in because it is possible that you don't actually want responses to be re-used. If you are caching responses, you will need to be aware of what to do when an authenticated user logs out. You will probably want to clear the cache so that they aren't still seeing content as if they were logged in."))});t.default=i},89:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=n(1),o=a(n(60)),i=n(3),u=n(9),s=n(8),c=function(e){var t=e.name;return l.default.createElement(o.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"If you are bundling an application with a lot of routes, users of your application may be downloading a lot of unnecessary content just to render the initial page. Using code splitting, you can reduce the initial download size for your application by splitting code that is conditionally loaded into a separate bundle that is only downloaded when it is needed."),l.default.createElement(u.Note,null,"This guide assumes that you are using Webpack 2+ to bundle your application."),l.default.createElement(s.Section,{title:"An app without code splitting",id:"no-split"},l.default.createElement("p",null,"Let's start out by describing our application's routes without code splitting. We will import each route's component from the files where they are defined."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"import Home from './components/Home';\nimport Contact from './components/Contact';\nimport ContactMethod from './components/ContactMethod';\n\nconst routes = [\n  {\n    name: 'Home',\n    path: '',\n    match: () => {\n      response: ({ set }) => {\n        set.body(Home);\n      }\n    }\n  },\n  {\n    name: 'Contact',\n    path: 'contact',\n    match: () => {\n      response: ({ set }) => {\n        set.body(Contact);\n      }\n    },\n    children: [\n      {\n        name: 'Contact Method',\n        path: ':method',\n        match: () => {\n          response: ({ set }) => {\n            set.body(ContactMethod);\n          }\n        }\n      }\n    ]\n  }\n];")),l.default.createElement(s.Section,{title:"import() in match.initial",id:"initial"},l.default.createElement("p",null,"Instead of having static imports, we will use the ",l.default.createElement(i.InlineJS,null,"import()")," ","function to import our modules. We will import our components using the"," ",l.default.createElement(i.InlineJS,null,"match.initial")," property of routes. This function will only be called the first time that its route matches, so we don't have to worry about making extra requests to our server."),l.default.createElement("p",null,l.default.createElement(i.InlineJS,null,"match.initial")," should be a function that returns a Promise;"," ",l.default.createElement(i.InlineJS,null,"import()"),", conveniently, returns a Promise. Then, in our"," ",l.default.createElement(i.InlineJS,null,"match.response")," function, instead of referencing values imported at the top of the file, we can reference the result of the"," ",l.default.createElement(i.InlineJS,null,"initial")," function using ",l.default.createElement(i.InlineJS,null,"resolved.initial"),"."),l.default.createElement("p",null,l.default.createElement(i.InlineJS,null,"import()")," resolves with a module object, so we will just assume that the component are default imports and reference them as"," ",l.default.createElement(i.InlineJS,null,"resolved.initial.default"),". Alternatively, we could just resolve the default value in our ",l.default.createElement(i.InlineJS,null,"match.initial")," function."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    name: 'Home',\n    path: '',\n    match: {\n      initial: () => import('./components/Home'),\n      response: ({ resolved, set }) => {\n        set.body(resolved.initial.default);\n      }\n    },\n    body: () => Home\n  },\n  {\n    name: 'Contact',\n    path: 'contact',\n    match: {\n      initial: () => import('./components/Contact'),\n      response: ({ resolved, set }) => {\n        set.body(resolved.initial.default);\n      }\n    },\n    body: () => Contact,\n    children: [\n      {\n        name: 'Contact Method',\n        path: ':method',\n        match: {\n          // we can resolve module.default in initial\n          // instead of in response\n          initial: () => import('./components/ContactMethod')\n            .then(module => module.default),\n            response: ({ resolved, set }) => {\n            set.body(resolved.initial);\n          }\n        },\n        body: () => ContactMethod\n      }\n    ]\n  }\n];")),l.default.createElement(s.Section,{title:"Next",id:"next"},l.default.createElement("p",null,"The approaches taken here are not the only way to do code splitting. You may choose to skip the ",l.default.createElement(i.InlineJS,null,"match.initial")," method and do code splitting at other points in your application. Whatever path you decide to go, hopefully this has shown you that setting up code splitting with the ",l.default.createElement(i.InlineJS,null,"match.initial")," property is fairly simple to do. If you are using Webpack and want to reduce your initial bundle size,"," ",l.default.createElement(i.InlineJS,null,"match.initial")," is an easy way to accomplish this."),l.default.createElement("p",null,"Next, we will take a look at some related route properties in"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"loading"}},"the loading guide"),".")))};t.default=c},90:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=n(1),o=a(n(60)),i=n(3),u=(n(9),n(8)),s=function(e){var t=e.name;return l.default.createElement(o.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"In the code splitting guide, we used the ",l.default.createElement(i.InlineJS,null,"match.initial")," property of routes. Routes also have ",l.default.createElement(i.InlineJS,null,"match.every")," and"," ",l.default.createElement(i.InlineJS,null,"match.response")," properties. While ",l.default.createElement(i.InlineJS,null,"initial"),"is only called the first time a route matches, ",l.default.createElement(i.InlineJS,null,"every")," and"," ",l.default.createElement(i.InlineJS,null,"response")," are called every time a route matches."),l.default.createElement(u.Section,{title:"every",id:"every"},l.default.createElement("p",null,l.default.createElement(i.InlineJS,null,"match.every")," is where you should perform any data loading for the matched route."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    name: 'Recipe',\n    path: 'recipe/:id'\n  }\n];"),l.default.createElement("p",null,"When the ",l.default.createElement(i.InlineJS,null,"Recipe")," route matches, we want to fetch data for that specific recipe (using the ",l.default.createElement(i.InlineJS,null,"id")," param from the path)."),l.default.createElement("p",null,"The ",l.default.createElement(i.InlineJS,null,"every"),' function will be passed a "route" object that contains ',l.default.createElement(i.InlineJS,null,"params"),", ",l.default.createElement(i.InlineJS,null,"location")," and ",l.default.createElement(i.InlineJS,null,"name")," ","properties. Between those properties, you should be able to create any data API requests."),l.default.createElement("p",null,"Just like the ",l.default.createElement(i.InlineJS,null,"match.initial")," function, ",l.default.createElement(i.InlineJS,null,"match.every")," ","is expected to return a Promise."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"{\n  name: 'Recipe',\n  path: 'recipe/:id',\n  match: {\n    every: ({ params }) => fakeAPI.getRecipe(params.id)\n  }\n}"),l.default.createElement("p",null,"Now, when we navigate to ",l.default.createElement(i.InlineJS,null,"/recipe/chocolate-chip-cookies"),", our"," ",l.default.createElement(i.InlineJS,null,"every")," function will call the fake API function to load the recipe. The function will resolve with the loaded data.")),l.default.createElement(u.Section,{title:"response",id:"response"},l.default.createElement("p",null,"While ",l.default.createElement(i.InlineJS,null,"match.every")," starts our data loading, it doesn't actually do anything. Instead, we should handle any loaded data with the"," ",l.default.createElement(i.InlineJS,null,"match.response")," function."),l.default.createElement("p",null,"You are probably wondering why this behavior is in a separate function. The reason is that while the ",l.default.createElement(i.InlineJS,null,"every")," function for a matched route is resolving, the user may navigate again, which overrides the current navigation. We cannot cancel the ",l.default.createElement(i.InlineJS,null,"every")," function for the current navigation, so if it performs any side effects, our application is stuck with them. To avoid this, the ",l.default.createElement(i.InlineJS,null,"response")," ","function is not called until we know that the current navigation will complete."),l.default.createElement("p",null,"The ",l.default.createElement(i.InlineJS,null,"response")," function will receive an object with a number of properties. These are covered in detail in the"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"routes"},details:{hash:"response"}},"All About Routes")," ","guide."),l.default.createElement("p",null,"Here, we will be using the ",l.default.createElement(i.InlineJS,null,"resolved")," and ",l.default.createElement(i.InlineJS,null,"set")," ","properties. We will use ",l.default.createElement(i.InlineJS,null,"set.data")," to attach the data loaded from our API to our response. Calling ",l.default.createElement(i.InlineJS,null,"set.data")," will set the"," ",l.default.createElement(i.InlineJS,null,"data")," property of the response object."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"{\n  name: 'Recipe',\n  path: 'recipe/:id',\n  match: {\n    every: ({ params }) => fakeAPI.getRecipe(params.id),\n    response                                                                                                                                     : ({ resolved, set }) => {\n      set.data(resolved);\n      set.body(Recipe);\n    }\n  }\n}"),l.default.createElement("p",null,"If at some point in time we decide that we want to change our URI pathname structure, we can also use the ",l.default.createElement(i.InlineJS,null,"match.response")," ","function to redirect."),l.default.createElement("p",null,"By calling the ",l.default.createElement(i.InlineJS,null,"set.redirect")," method, you can specify the route that we should redirect to."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"{\n  name: 'Old Recipe',\n  path: 'r/:id',\n  match: {\n    response: ({ route, set }) => {\n      // destructure the current location to preserve\n      // query/hash values\n      set.redirect({\n        name: 'Recipe',\n        params: route.params,\n        ...route.location\n      });\n    }\n  }\n}"),l.default.createElement("p",null,"After Curi emits the response, it will also automatically redirect to the new location!")),l.default.createElement("p",null,l.default.createElement(i.InlineJS,null,"every")," and ",l.default.createElement(i.InlineJS,null,"response")," offer a conveneint great place to do any route setup prior to actually rendering the route. Please remember, however, that your application will not be re-rendering until after the fetching has resolved. If you have a long running load function, you may wish to implement some sort of loading display. The"," ",l.default.createElement(r.Link,{to:"Example",params:{category:"react",slug:"data-loading"}},"data loading example")," ","shows one approach to how to do this."))};t.default=s},91:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=n(1),o=a(n(60)),i=n(3),u=n(9),s=n(8),c=function(e){var t=e.name;return l.default.createElement(o.default,null,l.default.createElement("h1",null,t),l.default.createElement(i.PrismBlock,{lang:"bash"},"npm install @curi/react"),l.default.createElement(u.Note,null,"This guide assumes that you are already familiar with React."),l.default.createElement("p",null,"Curi provides a number of React components through the"," ",l.default.createElement(r.Link,{to:"Package",params:{package:"react"}},l.default.createElement(i.InlineJS,null,"@curi/react"))," ","package. To get started, there are only two components that you need to be aware of: ",l.default.createElement(i.InlineComponent,null,"CuriProvider")," and ",l.default.createElement(i.InlineComponent,null,"Link"),"."),l.default.createElement(s.Section,{title:l.default.createElement(i.InlineComponent,null,"CuriProvider"),id:"CuriProvider"},l.default.createElement("p",null,"In order for other components to access router-related variables, we need to make them available through React's ",l.default.createElement(i.InlineJS,null,"context"),". The"," ",l.default.createElement(r.Link,{to:"Package",params:{package:"react"},details:{hash:"CuriProvider"}},l.default.createElement(i.InlineComponent,null,"CuriProvider"))," ","component is responsible for doing this. You pass it two props: a Curi"," ",l.default.createElement(i.InlineJS,null,"router")," and a ",l.default.createElement(i.InlineJS,null,"children")," render function. The"," ",l.default.createElement(i.InlineJS,null,"router")," will listen for new responses to be emitted and call the render function to re-render your application."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"import { CuriProvider } from '@curi/react';\n\n<CuriProvider router={router}>\n  {render}\n</CuriProvider>"),l.default.createElement(s.Subsection,{title:"The render function",id:"render-fn"},l.default.createElement("p",null,"The ",l.default.createElement(i.InlineJS,null,"children")," prop is a function that will be called every time the ",l.default.createElement(i.InlineComponent,null,"CuriProvider")," is rendered. The render function should return the React elements that make up your application."),l.default.createElement("p",null,"The ",l.default.createElement(i.InlineJS,null,"children")," render function receives an object with three properties to help you render your application: ",l.default.createElement(i.InlineJS,null,"response"),","," ",l.default.createElement(i.InlineJS,null,"navigation"),", and ",l.default.createElement(i.InlineJS,null,"router"),". The ",l.default.createElement(i.InlineJS,null,"response")," ","object is the most important of these, while the others may occasionally be useful or you may never use them."),l.default.createElement("p",null,"In our routes, we can attach a ",l.default.createElement(i.InlineJS,null,"body")," property to response objects, which we can then use in a ",l.default.createElement(i.InlineJS,null,"render")," function."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"import Home from './components/Home';\n\nconst routes = [\n  {\n    name: 'Home',\n    path: '',\n    match: {\n      response: ({ set }) => {\n        set.body(Home);\n      }\n    }\n  },\n  ...\n]"),l.default.createElement(i.PrismBlock,{lang:"javascript"},"function render({ response }) {\n  const { body:Body } = response;\n  return <Body />;\n}"),l.default.createElement(u.Note,null,'We rename "body" to "Body" so that the JSX is'," ",l.default.createElement("a",{href:"https://facebook.github.io/react/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized"},"transformed properly"),"."),l.default.createElement("p",null,"When no routes match, the body property of a response is"," ",l.default.createElement(i.InlineJS,null,"undefined"),". The best way to deal with this is with a catch all route."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"import NotFound from './components/NotFound';\n\nconst routes = [\n  // ...,\n  {\n    name: 'Not Found',\n    path: '(.*)' // this path matches EVERY pathname\n    match: {\n      response({ set }) {\n        set.body(NotFound);\n      }\n    }\n  }\n];"),l.default.createElement("p",null,"Finally, you can pass any props that you want to the ",l.default.createElement(i.InlineComponent,null,"Body")," ","component. Generally speaking, it is useful to pass the entire"," ",l.default.createElement(i.InlineJS,null,"response")," object. You can review all of the response properties in the"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"responses"},details:{hash:"response-properties"}},"Response Handlers")," ","guide."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"function render({ response }) {\n  const { body:Body } = response;\n  return <Body response={response} />;\n}"))),l.default.createElement(s.Section,{title:l.default.createElement(i.InlineComponent,null,"Link"),id:"link"},l.default.createElement("p",null,"A single page application isn't very useful if you cannot navigate between locations. The"," ",l.default.createElement(r.Link,{to:"Package",params:{package:"react"},details:{hash:"Link"}},l.default.createElement(i.InlineComponent,null,"Link"))," ","component provides you with an easy way to do this by rendering anchor (",l.default.createElement(i.InlineComponent,null,"a"),") elements."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"import { Link } from '@curi/react'\n<Link to='Home'>Home</Link>"),l.default.createElement("p",null,"The most important prop of the ",l.default.createElement(i.InlineComponent,null,"Link")," is ",l.default.createElement(i.InlineJS,null,"to"),". This value should be the name of the route that you want to navigate to. For instance, take about following route:"),l.default.createElement(i.PrismBlock,{lang:"javascript"},"{\n  name: 'About',\n  path: 'about',\n  ...\n}\n"),l.default.createElement("p",null,"If you were to render a Link whose to property is ",l.default.createElement(i.InlineJS,null,'"About"'),", then it would render an anchor whose ",l.default.createElement(i.InlineJS,null,"href")," attribute is"," ",l.default.createElement(i.InlineJS,null,"/about"),". The great thing about this is that you don't have to know the URI of the route that you want to navigate to, only its name because Curi handles creating URI pathnames for you."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"<Link to='About'>About</Link>\n// <a href=\"/about\">About</a>"),l.default.createElement("p",null,"That works well enough for simple paths, but what about paths that include params? For that, you need to pass an object using the"," ",l.default.createElement(i.InlineJS,null,"params")," property. This object's keys should be the same as the route's expected params. The params object should also include the params for any parent routes."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"{\n  name: 'Album',\n  path: 'a/:albumID',\n  ...,\n  children: [\n    {\n      name: 'Song',\n      path: ':songID',\n      ...\n    }\n  ]\n}\n\n<Link to='Song' params={{ albumID: 2390, songID: 7 }}>\n  Some Song on Some Album\n</Link>\n// <a href=\"/a/2390/7>Some Song on Some Album</a>"),l.default.createElement("p",null,"If you want to attach additional location information to a Link, you can do so using the ",l.default.createElement(i.InlineJS,null,"details")," prop. This is an object that has any other location properties that you want to link to. These would be"," ",l.default.createElement(i.InlineJS,null,"query"),", ",l.default.createElement(i.InlineJS,null,"hash"),", and ",l.default.createElement(i.InlineJS,null,"state"),"."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"<Link\n  to='Song'\n  params={{ albumID: 2390, songID: 8 }}\n  details={{ query: { time: 17 } }}\n>\n  Some Song on Some Album\n</Link>\n// <a href=\"/a/2390/8?time=17>Some Song on Some Album</a>"),l.default.createElement("p",null,"The ",l.default.createElement(i.InlineJS,null,"children")," prop will simply be passed as the children of the anchor, the same as if you were to use a regular anchor."),l.default.createElement(s.Subsection,{title:"Why not an anchor?",id:"why-link"},l.default.createElement("p",null,"We use a ",l.default.createElement(i.InlineComponent,null,"Link")," because a regular anchor would not work here. Clicking the anchor would cause a full page reload. The"," ",l.default.createElement(i.InlineComponent,null,"Link")," uses calls the ",l.default.createElement(i.InlineJS,null,"navigate")," method from your Hickory history object to allow for in-app navigation without reloading the page."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"// if you render this, clicking it will reload the page\n<a href=\"/about\">About</a>\n\n// while rendering this will not cause a reload\n<Link to='About'>About</Link>\n"),l.default.createElement("p",null,'Both of the above elements render the same thing to the page, an anchor element, but the "magic" is the Link\'s usage of your history object.')),l.default.createElement(u.Note,null,"This does not cover all of the Link props. Please check out the"," ",l.default.createElement(r.Link,{to:"Package",params:{package:"react"},details:{hash:"Link"}},"Link")," ","API docs to learn more about the other props.")),l.default.createElement("p",null,"The above guide should cover what you need to know to get started with using Curi and React. However, there are also more React components that you might find useful. You can read more about them in the"," ",l.default.createElement(r.Link,{to:"Package",params:{package:"react"}},l.default.createElement(i.InlineJS,null,"@curi/react"))," ","documentation."))};t.default=c},92:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=n(1),o=a(n(60)),i=n(3),u=n(9),s=n(8),c=function(e){var t=e.name;return l.default.createElement(o.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null),l.default.createElement(u.Note,null,"This guide assumes that you are already familiar with React Native."),l.default.createElement(s.Section,{title:"Back Button",id:"back-button"},"To add back button support, you just need to use your ",l.default.createElement(i.InlineJS,null,"history")," ","object (which you can use directly or access through your router).",l.default.createElement(i.PrismBlock,{lang:"javascript"},"import { BackHandler } from 'react-native';\n\n// create your router\nconst router = curi(history, routes);\n\nBackHandler.addEventListener(\"hardwareBackPress\", () => {\n  // close the app when pressing back button on initial screen\n  if (router.history.index === 0) {\n    return false;\n  }\n  router.history.go(-1);\n  return true;\n});")),l.default.createElement(s.Section,{title:"Components",id:"components"},l.default.createElement("p",null,"The"," ",l.default.createElement(r.Link,{to:"Package",params:{package:"react-native"}},l.default.createElement(i.InlineJS,null,"@curi/react-native"))," ","package is quite similar to the"," ",l.default.createElement(r.Link,{to:"Package",params:{package:"react"}},l.default.createElement(i.InlineJS,null,"@curi/react"))," ","package. In fact, Curi's React Native package just re-exports most of the components from the React package."),l.default.createElement(s.Subsection,{title:l.default.createElement(i.InlineComponent,null,"Link"),id:"components-link"},l.default.createElement("p",null,"The main difference is that they have different ",l.default.createElement(i.InlineComponent,null,"Link")," ","components. While the React package's ",l.default.createElement(i.InlineComponent,null,"Link")," renders an anchor by default, the React Native ",l.default.createElement(i.InlineComponent,null,"Link")," renders a"," ",l.default.createElement(i.InlineComponent,null,"TouchableHighlight")," by default."),l.default.createElement(u.Note,null,"Don't forget to wrap the ",l.default.createElement(i.InlineComponent,null,"Link"),"'s text in a ",l.default.createElement(i.InlineComponent,null,"Text"),"!"),l.default.createElement(i.PrismBlock,{lang:"jsx"},"import { Link } from '@curi/react-native';\n\n<Link to='Home'>\n  <Text>Home</Text>\n</Link>")),l.default.createElement(s.Subsection,{title:l.default.createElement(i.InlineComponent,null,"CuriProvider"),id:"componentsCuriProvider"},l.default.createElement("p",null,l.default.createElement(i.InlineJS,null,"@curi/react")," provides a ",l.default.createElement(i.InlineComponent,null,"CuriProvider")," component that will listen for new responses and re-render your application."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"import { CuriProvider } from '@curi/react-native';\n\nimport router from './router';\n\nconst App = () => (\n  <CuriProvider router={router}>\n    {({ response }) => {\n      const { body:Body } = response;\n      return <Body response={response} />;\n    }}\n  </CuriProvider>\n);"))))};t.default=c},93:function(e,t,n){"use strict";function a(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var l=a(n(0)),r=n(1),o=a(n(60)),i=n(3),u=n(9),s=n(8),c=function(e){var t=e.name;return l.default.createElement(o.default,null,l.default.createElement("h1",null,t),l.default.createElement("p",null,"The Curi router is somewhat similar to React Router versions 2 and 3, so migration is fairly easy. For instance, both use a centralized router. Both routers are made up of route objects (although with React Router some of these are disguised as JSX with ",l.default.createElement(i.InlineComponent,null,"Route")," components). With both, routes can be nested, allowing child routes to build off of the paths from their parent routes."),l.default.createElement("p",null,"Migration from React Router v2/3 to Curi should not require a complete reworking of your application, but there are some key differences."),l.default.createElement("ol",null,l.default.createElement("li",null,"The routing is handled entirely outside of React. With Curi, there are no ",l.default.createElement(i.InlineComponent,null,"Route")," components."),l.default.createElement("li",null,"With Curi, when a nested route matches, only that route renders. Any ancestor routes that also (partially) match are not rendered. This is different from React Router, where ancestors of the best matched route also render.")),l.default.createElement(s.Section,{title:"Routes",id:"routes"},l.default.createElement("p",null,"Lets get started with setting up our routes."),l.default.createElement(s.Subsection,{title:"With React Router",id:"routes-with-react-router"},l.default.createElement("p",null,"In React Router v2/3, there are two ways to define routes. You can either use JavaScript objects or JSX ",l.default.createElement(i.InlineComponent,null,"Route"),"s (which React Router converts to JavaScript objects)."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"// JavaScript objects\n{\n  path: '/',\n  component: App,\n  indexRoute: Home,\n  childRoutes: [\n    {\n      path: 'inbox',\n      component: Inbox,\n      childRoutes: [\n        {\n          path: ':message',\n          component: Message,\n          onEnter: (next) => {...},\n          onChange: (prev, next) => {...},\n          onLeave: (prev) => {...}\n        }\n      ]\n    }\n  ]\n// JSX\n<Route path='/' component={App}>\n  <IndexRoute component={Home} />\n  <Route path='inbox' component={Inbox}>\n    <Route\n      path=':message'\n      component={Message}\n      onEnter={next => {...}}\n      onChange={(prev, next) => {...}}\n      onLeave={prev => {...}}\n    />\n  </Route>\n</Route>"),l.default.createElement("p",null,"Both styles described above define the same route structure for three routes: ",l.default.createElement(i.InlineJS,null,"/"),", ",l.default.createElement(i.InlineJS,null,"/inbox"),", and"," ",l.default.createElement(i.InlineJS,null,"/inbox/:message"),". Each one of these has a component that will be rendered when it matches. The ",l.default.createElement(i.InlineJS,null,"/inbox/:message")," route has some methods defined to describe its behavior when the route enters, updates, and leaves.")),l.default.createElement(s.Subsection,{title:"With Curi",id:"routes-with-curi"},l.default.createElement("p",null,"Routes in Curi are always JavaScript objects. Like React Router, each route object has a path property that describes the path segments that the route matches. React Router v2/3 uses a custom path matcher, but Curi uses ",l.default.createElement(i.InlineJS,null,"path-to-regexp"),". You can read learn how to format paths from the"," ",l.default.createElement("a",{href:"https://github.com/pillarjs/path-to-regexp"},l.default.createElement(i.InlineJS,null,"path-to-regexp")," repo"),"."),l.default.createElement("p",null,"First, we will just define the paths for our routes."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    path: ''\n  },\n  {\n    path: 'inbox',\n    children: [\n      {\n        path: ':message'\n      }\n    ]\n  }\n];"),l.default.createElement("p",null,"The biggest difference between the Curi paths and the React Router paths is that with Curi, you never include a forward slash at the beginning of the path. This means that while the root path for React Router is ",l.default.createElement(i.InlineJS,null,"'/'"),", the root path for Curi is ",l.default.createElement(i.InlineJS,null,"''"),"."),l.default.createElement("p",null,"Next, we should add our components to each route. We will ignore the"," ",l.default.createElement(i.InlineComponent,null,"App")," component that is used in the React Router routes. That is not route specific and will be rendered by our application (assuming we actually need it)."),l.default.createElement("p",null,"With Curi routes, we have a ",l.default.createElement(i.InlineJS,null,"match")," property. This is an object with a couple different optional function properties, but the one we care about right now is ",l.default.createElement(i.InlineJS,null,"match.response"),". In our"," ",l.default.createElement(i.InlineJS,null,"match.response")," function, we have a ",l.default.createElement(i.InlineJS,null,"set")," object that we can use to modify the response. One of the properties of this object is a ",l.default.createElement(i.InlineJS,null,"body")," function that we can call to set the"," ",l.default.createElement(i.InlineJS,null,"body")," property of the response. For this React application, we want our ",l.default.createElement(i.InlineJS,null,"body")," property to be the React component associated with each route."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    path: '',\n    match: {\n      response: ({ set }) => {\n        set.body(Home);\n      }\n    }\n  },\n  {\n    path: 'inbox',\n    match: {\n      response: ({ set }) => {\n        set.body(Inbox);\n      }\n    }\n    children: [\n      {\n        path: ':message',\n        match: {\n          response: ({ set }) => {\n            set.body(Message);\n          }\n        }\n      }\n    ]\n  }\n];"),l.default.createElement("p",null,"We are close to replicating our React Router routes, we just have to implement the ",l.default.createElement(i.InlineJS,null,"on___")," methods for our",l.default.createElement(i.InlineJS,null,":message")," ","route. With Curi, routes have two possible loading function properties: ",l.default.createElement(i.InlineJS,null,"match.initial")," and ",l.default.createElement(i.InlineJS,null,"match.every"),"."," ",l.default.createElement(i.InlineJS,null,"match.initial")," is useful for tasks that only need to be run once per route, like the code splitting mentioned above."," ",l.default.createElement(i.InlineJS,null,"match.every"),", on the other hand, will be called every time that a route matches."),l.default.createElement("p",null,"With React Router, ",l.default.createElement(i.InlineJS,null,"onEnter")," is called when the route first matches, while ",l.default.createElement(i.InlineJS,null,"onChange")," is called when the same route matches a new location (e.g. with new path parameters)."," ",l.default.createElement(i.InlineJS,null,"onEnter")," and ",l.default.createElement(i.InlineJS,null,"onChange")," are nearly the same; the big difference between the two is that ",l.default.createElement(i.InlineJS,null,"onChange")," will receive the previous props, which could be used to determine which props changed. When converting these to Curi, we will use"," ",l.default.createElement(i.InlineJS,null,"match.every")," for both. This misses out on the ability to compare props in ",l.default.createElement(i.InlineJS,null,"onChange"),", but the primary purpose for comparing props in ",l.default.createElement(i.InlineJS,null,"onChange")," was to know whether you're navigating to a new route or just swapping query/hash values, so a cache should serve the same purpose."),l.default.createElement("p",null,"Curi routes can also have a ",l.default.createElement(i.InlineJS,null,"match.response")," property which you can use to modify the response object. This function will run once we know that the response will be emitted, so side effects can be run in here."),l.default.createElement("p",null,"There currently is no equivalent to ",l.default.createElement(i.InlineJS,null,"onLeave")," with Curi. This is mostly because I havent seen a compelling need for it. It certainly could be implemented, but so far I have not found a reason to use that. If you have something you need this functionality for, please open up an issue in the GitHub repo."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    path: '',\n    match: {\n      response: ({ set }) => {\n        set.body(Home);\n      }\n    }\n  },\n  {\n    path: 'inbox',\n    match: {\n      response: ({ set }) => {\n        set.body(Inbox);\n      }\n    }\n    children: [\n      {\n        path: ':message',\n        match: {\n          every: (route) => { return ... },\n          response: ({ set }) => {\n            set.body(Message);\n          }\n        }\n      }\n    ]\n  }\n];"),l.default.createElement("p",null,"The"," ",l.default.createElement(r.Link,{to:"Guide",params:{slug:"routes"},details:{hash:"match"}},"routes guide")," ","covers all of the ",l.default.createElement(i.InlineJS,null,"match")," functions and their arguments."),l.default.createElement("p",null,"We now have the equivalent routes implemented in Curi, but we have one last step. With Curi, each route has to have a unique name."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"const routes = [\n  {\n    name: 'Home',\n    path: '',\n    match: {\n      response: ({ set }) => {\n        set.body(Home);\n      }\n    }\n  },\n  {\n    name: 'Inbox',\n    path: 'inbox',\n    match: {\n      response: ({ set }) => {\n        set.body(Inbox);\n      }\n    }\n    children: [\n      {\n        name: 'Message',\n        path: ':message',\n        match: {\n          every: (route) => { return ... },\n          response: ({ set }) => {\n            set.body(Message);\n          }\n        }\n      }\n    ]\n  }\n];"),l.default.createElement("p",null,"Curi uses route names to allow you to interact with routes. For example, you can navigate to the Inbox route just by knowing its name instead of its URI. This can be especially handy when dealing with complicated pathnames or if you need to change the URI structure of your website. With Curi, you never have to write a URI yourself!")),l.default.createElement("p",null,"Once your routes have been defined, you can move on to creating your Curi router.")),l.default.createElement(s.Section,{title:"Creating the router",id:"creating-the-router"},l.default.createElement("p",null,"With React Router, you create your router by rendering a"," ",l.default.createElement(i.InlineComponent,null,"Router"),". That either takes the ",l.default.createElement(i.InlineComponent,null,"Route")," components as props or the route objects through its ",l.default.createElement(i.InlineJS,null,"routes")," prop. The"," ",l.default.createElement(i.InlineComponent,null,"Router")," also takes a ",l.default.createElement(i.InlineJS,null,"history")," prop, which is either one of the pre-routerured objects (",l.default.createElement(i.InlineJS,null,"browserHistory")," or"," ",l.default.createElement(i.InlineJS,null,"hashHistory"),") or one that you create yourself."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"import { Router, browserHistory } from 'react-router';\nconst routes = [...];\nReactDOM.render((\n  <Router history={browserHistory} routes={routes} />\n), holder);"),l.default.createElement("p",null,"With Curi, the router is created prior to rendering. It takes a Hickory history object, your routes array, and possibly an options object.",l.default.createElement("a",{href:"https://github.com/pshrmn/hickory"},"Hickory")," ","is similar to the ",l.default.createElement(i.InlineJS,null,"history")," package used by React Router, but has a slight modified API (easier navigation blocking and navigation that imitates how anchors work) and more convenient location objects (you can use a ",l.default.createElement(i.InlineJS,null,"query")," object instead of having to manually create a ",l.default.createElement(i.InlineJS,null,"search")," string)."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"import curi from '@curi/core';\nimport Browser from '@hickory/browser';\nconst history = Browser();\nconst routes = [...];\nconst router = curi(history, routes);")),l.default.createElement(s.Section,{title:"Rendering",id:"rendering"},l.default.createElement("p",null,"At this point, our Curi router isnt actually quite ready to render. Curi creates response objects asynchronously, so if we render right away, we might not have a response object to render with. We can work around this by rendering nothing (",l.default.createElement(i.InlineJS,null,"null"),") at first, but instead we should usually just wait for our initial response to be ready."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"router.respond(({ response }) => {\n  // now our first response has resolved, so we\n  // know that we will render with an actual response\n});"),l.default.createElement("p",null,"We will walk through the rendering differences between React Router and Curi by looking at what happens in each when we navigate to the URI"," ",l.default.createElement(i.InlineJS,null,"/inbox/test-message-please-ignore"),"."),l.default.createElement(s.Subsection,{title:"React Router v2/3",id:"rendering-react-router"},l.default.createElement("p",null,"React Router uses the ",l.default.createElement(i.InlineComponent,null,"Router")," component to subscribe to location changes. Each time that the location changes, it walks over its routes and determines which route(s!) match."),l.default.createElement("p",null,"React Router starts by rendering the root component. In the above router, that is the ",l.default.createElement(i.InlineComponent,null,"App"),". Next, our ",l.default.createElement(i.InlineJS,null,"inbox")," route also matches, so React Router also renders our ",l.default.createElement(i.InlineComponent,null,"Inbox")," ","component. Finally, the URI"," ",l.default.createElement(i.InlineJS,null,"/inbox/test-message-please-ignore")," also matches our",l.default.createElement(i.InlineJS,null,":message")," ","route (which is concatenated with its parents to form the path"," ",l.default.createElement(i.InlineJS,null,"/inbox/:message"),"), so ",l.default.createElement(i.InlineComponent,null,"Message")," is rendered as well. Each child component is rendered by its parent, so we end up with a component tree that looks something like this:"),l.default.createElement(i.PrismBlock,{lang:"jsx"},"<App>\n  <Inbox>\n    <Message>\n  </Inbox>\n</App>"),l.default.createElement("p",null,"With this structure, any routes with children will be rendered when one of the children matches. That means that those routes need to know how to render based on what type of match they have. For example,"," ",l.default.createElement(i.InlineComponent,null,"Inbox")," needs to know how to render for an exact match (the URI is ",l.default.createElement(i.InlineJS,null,"/inbox"),") and for a partial match (",l.default.createElement(i.InlineJS,null,"/inbox/test-message-please-ignore"),"). Also, if the ",l.default.createElement(i.InlineComponent,null,"Inbox")," needs to pass any props to"," ",l.default.createElement(i.InlineComponent,null,"Message"),", it has to use ",l.default.createElement(i.InlineJS,null,"React.cloneElement"),", which works but is not the cleanest looking code.")),l.default.createElement(s.Subsection,{title:"Curi",id:"rendering-with-curi"},l.default.createElement("p",null,"With Curi, we also need to re-render our application every time that the location changes. We will do this using the"," ",l.default.createElement(i.InlineComponent,null,"CuriProvider")," component, which comes from the"," ",l.default.createElement(i.InlineJS,null,"@curi/react")," package."),l.default.createElement("p",null,"The ",l.default.createElement(i.InlineComponent,null,"CuriProvider")," takes a ",l.default.createElement(i.InlineJS,null,"router")," prop, which it will use to listen for the router to emit new responses (by internally calling ",l.default.createElement(i.InlineJS,null,"router.respond"),") The ",l.default.createElement(i.InlineComponent,null,"CuriProvider")," places the new ",l.default.createElement(i.InlineJS,null,"response")," and ",l.default.createElement(i.InlineJS,null,"navigation")," (alongside the"," ",l.default.createElement(i.InlineJS,null,"router")," object) on React's ",l.default.createElement(i.InlineJS,null,"context")," so that child components will be able to access those values."," ",l.default.createElement(i.InlineComponent,null,"CuriProvider")," also expects a render function as its"," ",l.default.createElement(i.InlineJS,null,"children")," prop."),l.default.createElement("p",null,"We will also use ",l.default.createElement(i.InlineJS,null,"router.respond")," to wait for the initial response to be emitted before rendering."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"router.respond(() => {\n  ReactDOM.render((\n    <CuriProvider router={router}>\n      {({ response }) => {...}}\n    </CuriProvider>\n  ), holder);\n});"),l.default.createElement("p",null,"So what should your render function look like? The render function will receive an object with three properties: ",l.default.createElement(i.InlineJS,null,"response"),", the new response object, ",l.default.createElement(i.InlineJS,null,"navigation"),", an object with additional information about the navigation, and ",l.default.createElement(i.InlineJS,null,"router"),", your Curi router. We will ignore the ",l.default.createElement(i.InlineJS,null,"navigation")," and ",l.default.createElement(i.InlineJS,null,"router")," ","here because the ",l.default.createElement(i.InlineJS,null,"response")," is what we really want."),l.default.createElement("p",null,"Earlier, we added ",l.default.createElement(i.InlineJS,null,"body")," properties to each of the routes and said that when a route matches, that function would be called and its return value would be attached to the response. That means, that inside of our render function, we can access the matched routes component as ",l.default.createElement(i.InlineJS,null,"response.body"),"."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body } = response;\n  return <Body />;\n}"),l.default.createElement("p",null,"That isnt perfect because it doesnt consider what happens when there is no body (which happens if none of the routes match the location or you don't set it in a route's ",l.default.createElement(i.InlineJS,null,"match.response")," function)."),l.default.createElement(u.Note,null,"Wildcard routes (",l.default.createElement(i.InlineJS,null,"{ path: '(.*)' }"),") can be used to easily display a not found page for any location not matched by other routes."),l.default.createElement("p",null,"Lets get back to our ",l.default.createElement(i.InlineJS,null,"response")," object. In the React Router section, we had three components that were rendered: ",l.default.createElement(i.InlineComponent,null,"App"),",",l.default.createElement(i.InlineComponent,null,"Inbox"),", and ",l.default.createElement(i.InlineComponent,null,"Message"),". With Curi, only the most accurately matched route actually matches. That means that for the URI"," ",l.default.createElement(i.InlineJS,null,"/inbox/test-message-please-ignore"),", the ",l.default.createElement(i.InlineJS,null,'"Message"')," ","route will match, but its parent route, ",l.default.createElement(i.InlineJS,null,'"Inbox"')," will not. The ",l.default.createElement(i.InlineJS,null,"response.body")," will be the ",l.default.createElement(i.InlineComponent,null,"Message")," component, so that is what our ",l.default.createElement(i.InlineJS,null,"render")," function will render. We dont render ",l.default.createElement(i.InlineComponent,null,"Inbox")," because we did not match the ",l.default.createElement(i.InlineJS,null,"inbox")," ","route."),l.default.createElement("p",null,"It was mentioned above that there is no need for the ",l.default.createElement(i.InlineComponent,null,"App")," ","component with Curi. If you want to have an ",l.default.createElement(i.InlineComponent,null,"App")," component, you can render it either inside of the ",l.default.createElement(i.InlineJS,null,"render")," function or as a parent of your ",l.default.createElement(i.InlineComponent,null,"CuriProvider"),". This can be useful for rendering content that is unrelated to specific routes, like a page header or menu."),l.default.createElement("p",null,"Rendering the ",l.default.createElement(i.InlineComponent,null,"App")," inside of the render function is necessary if any of the components rendered by the ",l.default.createElement(i.InlineComponent,null,"App")," are location aware components, since they need to access the Curi router (through Reacts context, which the ",l.default.createElement(i.InlineComponent,null,"CuriProvider")," provides)"),l.default.createElement(i.PrismBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body } = response;\n  return (\n    <App>\n      <Body />\n    </App>\n  );\n}\n// or\nfunction render({ response }) {\n  const { body:Body } = response;\n  return (\n    <div>\n      <Header />\n      <Body />\n      <Footer />\n    </div>\n  );\n}"),l.default.createElement("p",null,"What about props that you want to send to your route components? Just pass them to the ",l.default.createElement(i.InlineComponent,null,"Body")," component that you render."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"function render({ response }) {\n  const { body:Body, data, params } = response;\n  return <Body data={data} params={params} />;\n}"),l.default.createElement("p",null,"The one catch here is that you will be passing the same props to all of your route components. You could add fine-grained control by using"," ",l.default.createElement(i.InlineJS,null,"response.name")," and a ",l.default.createElement(i.InlineJS,null,"switch")," or ",l.default.createElement(i.InlineJS,null,"if"),"/",l.default.createElement(i.InlineJS,null,"else")," ","chain, but this is probably overkill. If youre worried about polluting the route components props, just pass the whole response object."))),l.default.createElement(s.Section,{title:"Links",id:"links"},l.default.createElement("p",null,"You obviously will want to be able to navigate between routes in your application. React Router provides a ",l.default.createElement(i.InlineComponent,null,"Link")," component to do this, and so does Curi (through the ",l.default.createElement(i.InlineJS,null,"@curi/react")," package). There are a few differences to note between these two components:"),l.default.createElement("ul",null,l.default.createElement("li",null,l.default.createElement("p",null,"React Router expects you to generate the pathname yourself, while Curi expects you to pass the name of the route that you want to navigate to. Any path parameters are passed to Curis"," ",l.default.createElement(i.InlineComponent,null,"Link")," using the ",l.default.createElement(i.InlineJS,null,"params")," prop."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"// React Router\n<Link to='/'>Home</Link>\n<Link to={`/inbox/${message}`}>Hello</Link>\n// Curi\n<Link to='Home'>Home</Link>\n<Link to='Message' params={{ message }}>Hello</Link>")),l.default.createElement("li",null,l.default.createElement("p",null,"With React Router, any additional location properties are passed to the ",l.default.createElement(i.InlineComponent,null,"Link")," using the ",l.default.createElement(i.InlineJS,null,"to")," object. With Curi, these properties are passed using the ",l.default.createElement(i.InlineJS,null,"details")," prop."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"// React Router\n<Link to={{ pathname: '/inbox', hash: '#test' }}>Inbox</Link>\n// Curi\n<Link to='Inbox' details={{ hash: 'test' }}>Inbox</Link>")),l.default.createElement("li",null,l.default.createElement("p",null,"Active detection with Curi is more complicated than with React Router, but also more powerful. With Curi, you provide a"," ",l.default.createElement(i.InlineJS,null,"merge")," function that receives the props that will used to render the ",l.default.createElement(i.InlineComponent,null,"a")," and allows you to modify/add props. You can also pass ",l.default.createElement(i.InlineJS,null,"partial: true")," to allow for partial matches to be considered active (the opposite of React Router's"," ",l.default.createElement(i.InlineJS,null,"onlyActiveOnIndex"),")."),l.default.createElement(i.PrismBlock,{lang:"jsx"},"// React Router\n<Link\n  to='/'\n  onlyActiveOnIndex\n  activeClassName='active'\n>Home</Link>\n// Curi\n// You need to add @curi/addon-active to your router object\nimport createActiveAddon from '@curi/addon-active';\nconst router = curi(history, routes, {\n  createActiveAddon\n});\n\n// pass the merge function to your <Link>. The props it returns\n// will be passed to the anchor rendered by the <Link>\nfunction merge(props) {\n  props.className = 'active';\n  return props;\n}\n<Link\n  to='Home'\n  active={{ merge }}\n>Home</Link>")))),l.default.createElement(s.Section,{title:"Accessing router props from nested components",id:"router-props"},l.default.createElement("p",null,"React Router provides a ",l.default.createElement(i.InlineJS,null,"withRouter")," higher-order component that will inject router props into the wrapped component. Curi provides similar functionality with the ",l.default.createElement(i.InlineJS,null,"curious")," higher-order component provided by the ",l.default.createElement(i.InlineJS,null,"@curi/react")," package."),l.default.createElement(i.PrismBlock,{lang:"javascript"},"export default withRouter(SomeComponent);\nexport default curious(SomeComponent);"),l.default.createElement("p",null,l.default.createElement(i.InlineJS,null,"curious")," will inject the Curi router and the current response object into the wrapped component.")),l.default.createElement("p",null,"At this point, hopefully you are comfortable with migrating from React Router v2/3 to Curi. If there are any concepts not covered here that you think should be, please feel free to open up an issue"," ",l.default.createElement("a",{href:"https://github.com/pshrmn/curi/issues"},"on GitHub"),"."))};t.default=c}});