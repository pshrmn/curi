<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Server-Side Rendering Guide | Curi Documentation</title>
    <link href="https://fonts.googleapis.com/css?family=Zilla+Slab:300,400" rel="stylesheet">
    <link href="/static/css/prism.css" rel="stylesheet">
  </head>
  <body>
    <div id="root"><style data-emotion-css="bg7vvq">body{font-family:"Zilla Slab",serif;font-weight:300;font-size:24px;line-height:36px;margin:0;box-sizing:border-box;}@media only screen and (min-width:751px){body{font-size:20px;}}@media only screen and (min-width:){body{font-size:20px;}}*,*:before,*:after{box-sizing:inherit;}h1,h2,h3,h4,h5,h6{font-weight:normal;margin:5px 0;}p{margin:5px 0;}h1{font-size:1.75em;}h2{font-size:1.5em;}h3{font-size:1.25em;}h4{font-size:1.2em;}h5{font-size:1.1em;}h6{font-size:1em;}table,th,td{border:1px solid #c7c7c7;border-collapse:collapse;}table{margin-bottom:10px;}th{text-align:left;}th,td{padding:10px;}pre[class*="language-"]{margin:0;background:#222233;}:not(pre) > code[class*="language-"]{white-space:nowrap;}</style><style data-emotion-css="1xrs380">.css-1xrs380{display:none;}@media only screen and (min-width:751px){.css-1xrs380{display:block;width:100vw;background:#222233;padding:0;position:fixed;z-index:1;}.css-1xrs380 .home-link{font-size:1.5em;color:#ff9800;}}</style><header class="css-1xrs380 e17onxz0"><style data-emotion-css="1exs64t">.css-1exs64t{width:751px;margin:0 auto;color:#efefef;}.css-1exs64t ul{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-flow:row wrap;-ms-flex-flow:row wrap;flex-flow:row wrap;-webkit-align-items:flex-end;-webkit-box-align:flex-end;-ms-flex-align:flex-end;align-items:flex-end;list-style:none;padding:0;margin:0;max-width:100%;}.css-1exs64t li{margin-right:20px;padding:0;}.css-1exs64t a{color:#efefef;font-size:1.1em;-webkit-text-decoration:none;text-decoration:none;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:50px;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-bottom:3px solid #222233;padding:0 5px;}.css-1exs64t a:hover{color:#ff9800;}.css-1exs64t a.active{color:#ff9800;border-bottom-color:#ff9800;}.css-1exs64t a.activated{color:#2196f3;border-bottom-color:#2196f3;}</style><nav class="css-1exs64t e17onxz1"><ul><li><a class="home-link " href="/">Curi</a></li><li><a data-hide="false" class=" " href="/packages/">API</a></li><li><a data-hide="false" class=" active" href="/guides/">Guides</a></li><li><a data-hide="false" class=" " href="/tutorial/">Tutorials</a></li><li><a data-hide="false" class=" " href="/examples/">Examples</a></li><li><a href="https://github.com/pshrmn/curi">GitHub</a></li></ul></nav><style data-emotion-css="1dskmbx">@media only screen and (min-width:751px){.css-1dskmbx{background:#deeffe;border-bottom:2px solid #222233;}.css-1dskmbx > div{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-flow:row wrap;-ms-flex-flow:row wrap;flex-flow:row wrap;-webkit-box-pack:space-around;-webkit-justify-content:space-around;-ms-flex-pack:space-around;justify-content:space-around;width:751px;margin:0 auto;}.css-1dskmbx a{color:#222233;-webkit-text-decoration:none;text-decoration:none;}.css-1dskmbx ul{list-style:none;margin:0;padding:0;}}</style><div style="border-bottom-width:0px" class="css-1dskmbx e17onxz2"></div></header><style data-emotion-css="17yb0j4">.css-17yb0j4{position:fixed;right:15px;bottom:15px;width:75px;height:75px;border-radius:40px;border:0;background:#64b5f6;font-size:1em;font-family:"Zilla Slab",serif;z-index:9999;}@media only screen and (min-width:751px){.css-17yb0j4{display:none;}}</style><button type="button" class="toggler css-17yb0j4 egebhwa1">Menu</button><style data-emotion-css="b9kg8f">.css-b9kg8f{display:none;position:fixed;overflow-y:scroll;width:100vw;height:100vh;background:#efefef;z-index:999;padding:15px;}.css-b9kg8f.visible{display:block;}.css-b9kg8f ul{margin:3px 0;padding-left:0px;list-style:none;}.css-b9kg8f li{margin:3px 0;}.css-b9kg8f a{-webkit-text-decoration:none;text-decoration:none;display:inline-block;color:#222233;}.css-b9kg8f h3{border-bottom:1px solid #333;}.css-b9kg8f .active{font-weight:bold;}.css-b9kg8f .children{display:none;background:#efefef;padding:10px;}.css-b9kg8f .children.visible{display:block;position:fixed;top:0;bottom:0;left:0;right:0;overflow-y:scroll;}@media only screen and (min-width:751px){.css-b9kg8f{display:none;}.css-b9kg8f.visible{display:none;}}</style><div hidden="" class=" css-b9kg8f egebhwa0"><nav><ul><li><a class="home-link " href="/">Curi</a></li><li><style data-emotion-css="eh8tip">.css-eh8tip a{color:#222233;}.css-eh8tip ul{margin-left:10px;}.css-eh8tip > li{margin-bottom:15px;}</style><ul class="css-eh8tip e11f272a0"><li><div><style data-emotion-css="12lsm47">.css-12lsm47{cursor:pointer;font-size:24px;font-family:"Zilla Slab",serif;text-align:left;width:100%;background:none;border:0;padding:0;color:#222233;}</style><button title="Toggle group visibility" class="css-12lsm47 e11f272a1"><svg width="25" height="15" viewBox="0 0 25 15" xmlns="http://www.w3.org/2000/svg"><path d="M2,5 l5,5 l5,-5" fill="none" stroke="black" stroke-width="3"></path></svg>API</button></div></li></ul></li><li><ul class="css-eh8tip e11f272a0"><li><div><button title="Toggle group visibility" class="css-12lsm47 e11f272a1"><svg width="25" height="15" viewBox="0 0 25 15" xmlns="http://www.w3.org/2000/svg"><path d="M2,5 l5,5 l5,-5" fill="none" stroke="black" stroke-width="3"></path></svg>Guides</button></div></li></ul></li><li><ul class="css-eh8tip e11f272a0"><li><div><button title="Toggle group visibility" class="css-12lsm47 e11f272a1"><svg width="25" height="15" viewBox="0 0 25 15" xmlns="http://www.w3.org/2000/svg"><path d="M2,5 l5,5 l5,-5" fill="none" stroke="black" stroke-width="3"></path></svg>Tutorials</button></div></li></ul></li><li><ul class="css-eh8tip e11f272a0"><li><div><button title="Toggle group visibility" class="css-12lsm47 e11f272a1"><svg width="25" height="15" viewBox="0 0 25 15" xmlns="http://www.w3.org/2000/svg"><path d="M2,5 l5,5 l5,-5" fill="none" stroke="black" stroke-width="3"></path></svg>Examples</button></div></li></ul></li><li><a href="https://github.com/pshrmn/curi">GitHub</a></li></ul></nav></div><style data-emotion-css="wdkxre">.css-wdkxre{width:100vw;padding:10px 10px 0;margin-bottom:20px;}.css-wdkxre a{color:#222233;}@media only screen and (min-width:751px){.css-wdkxre{padding:50px 25px 0;width:751px;margin:0 auto;}}</style><main tabindex="-1" style="outline:none" class="css-wdkxre e1fl12nk0"><style data-emotion-css="1ifjy1">.css-1ifjy1{position:relative;}@media only screen and (min-width:751px){.css-1ifjy1{padding-top:15px;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-flow:row nowrap;-ms-flex-flow:row nowrap;flex-flow:row nowrap;}}</style><div class="css-1ifjy1 e37tu9n0"><style data-emotion-css="3seevh">@media only screen and (min-width:751px){.css-3seevh{-webkit-order:2;-ms-flex-order:2;order:2;-webkit-flex:0 1 800px;-ms-flex:0 1 800px;flex:0 1 800px;position:relative;padding:0;overflow:hidden;outline:none;}}</style><div class="css-3seevh e826bmj0"><h1>Server-Side Rendering</h1><style data-emotion-css="cv69qk">.css-cv69qk{width:100%;}.css-cv69qk p{margin:0 0 25px;font-size:0.8em;}@media only screen and (min-width:751px){.css-cv69qk p{font-size:1em;}}</style><div class="css-cv69qk e12etsbl1"><p>Server-side rendering (SSR) allows an application to generate the HTML for pages on the server. While not strictly necessary for single-page applications, server-side rendering can potentially be beneficial by:</p><ol><li>Speeding up the initial render time.</li><li>Making it easier for web crawlers to view the application&#x27;s content (which <em>may</em> improve SEO).</li></ol><p>This guide will cover how to setup server-side rendering and some of the issues that you may run into.</p></div><style data-emotion-css="2fdgsn">.css-2fdgsn{margin-top:15px;}.css-2fdgsn .aside{padding:5px 10px;border-left:2px solid $border-green;background:#e8f5e9;margin-top:15px;}.css-2fdgsn .aside .inline-code{background:#81c784 !important;}.css-2fdgsn .header-link{-webkit-text-decoration:none;text-decoration:none;}.css-2fdgsn .header-link::after{content:"#";color:#333;margin-left:5px;display:none;}.css-2fdgsn .header-link:hover::after{display:inline-block;}@media only screen and (min-width:751px){.css-2fdgsn{max-width:800px;}.css-2fdgsn .displaced-header:before{content:"";display:block;margin-top:-50px;height:50px;visibility:hidden;}}</style><div class="section css-2fdgsn" id="reuse"><h2 class="displaced-header"><a class="header-link" href="#reuse">Reusing Code</a></h2><div class="css-cv69qk e12etsbl1"><p>Being able to reuse code on the client and server is one of the benefits of JavaScript. If you are using syntax in your client-side code that Node doesn&#x27;t know how to parse, such as import/export or JSX, you may quickly run into issues.</p><p>The <a href="https://babeljs.io/">Babel</a> package<!-- --> <style data-emotion-css="14f7g1f">.css-14f7g1f{padding:0.1em;border-radius:0.3em;white-space:normal;background:#fff !important;color:#222233 !important;text-shadow:none;white-space:wrap;}.css-14f7g1f .token{color:#222233;}</style><code class="inline-code language-javascript css-14f7g1f eutm4hs0">@babel/node</code> lets Babel compile your code on the fly to syntax that Node understands. Anywhere that you would call<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">node &lt;command&gt;</code>, you should call<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">babel-node &lt;command&gt;</code> instead.</p></div><style data-emotion-css="pr87ee">.css-pr87ee{width:100%;margin:0 0 25px;font-size:0.8em;}.css-pr87ee pre{white-space:pre-wrap;height:100%;vertical-align:top;}@media only screen and (min-width:751px){.css-pr87ee{font-size:1em;}.css-pr87ee code{min-width:200px;}}</style><div class="css-pr87ee e12etsbl0"><pre><code class="language-bash">npm install --save-dev @babel/node</code></pre></div><style data-emotion-css="1p6f91g">.css-1p6f91g{padding:10px 5px;margin:5px 0;background:#ffe8bf;border:1px solid #ff9800;}.css-1p6f91g .inline-code{background:#ffb74d !important;}</style><div class="css-1p6f91g e1bjkffy1"><strong>Warning:</strong> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">@babel/node</code> should only be used in development. For production, the server&#x27;s modules should be pre-compiled (using Babel).</div></div><div class="section css-2fdgsn" id="framework"><h2 class="displaced-header"><a class="header-link" href="#framework">Web Framework</a></h2><div class="css-cv69qk e12etsbl1"><p>In order to render JavaScript on the server, you will need to use Node. This guide will be using the<!-- --> <a href="https://expressjs.com/">Express</a> web framework.</p><style data-emotion-css="mezw60">.css-mezw60{padding:10px 5px;margin:5px 0;background:#eeeeee;border:1px solid #c7c7c7;}.aside .css-mezw60{background:#fff;}.css-mezw60 .inline-code{background:#fff !important;}</style><div class="css-mezw60 e1bjkffy0"><strong>Note:</strong> <!-- -->There are ways to mix Node server-side rendering with non-Node frameworks, but that is outside of the scope of this guide.</div><p>Familiarity with Express is not expected, so to get you started, this guide will provide some code snippets for a basic setup.</p></div><div class="css-pr87ee e12etsbl0"><pre><code class="language-bash">npm install express</code></pre></div><div class="css-cv69qk e12etsbl1"><p>The server&#x27;s setup code can be placed anywhere, but we will follow Node&#x27;s convention and save it in a <code class="inline-code language-javascript css-14f7g1f eutm4hs0">server.js</code> file.</p></div><div class="css-pr87ee e12etsbl0"><pre><code class="language-javascript">// server.js
const express = require(&quot;express&quot;);

const app = express();

// ...

app.listen(&quot;8080&quot;, () =&gt; {
  console.log(&quot;Server is running.&quot;);
});</code></pre></div><div class="css-pr87ee e12etsbl0"><pre><code class="language-bash"># tell node to start the server
# (development only!)
babel-node server.js</code></pre></div><div class="css-cv69qk e12etsbl1"><p>With the server ready to go, we can start configuring it to render a single-page application.</p></div></div><div class="section css-2fdgsn" id="request-matching"><h2 class="displaced-header"><a class="header-link" href="#request-matching">Request Matching</a></h2><div class="css-cv69qk e12etsbl1"><p>A web framework receives requests from the client and returns responses.</p><p>In the client-side application, we define the routes that are valid for the application. Similarly, the server needs to define which request paths are valid so that it can properly respond to them.</p><p>Server paths are given handler functions. These can do a variety of things, but we will only be using them to send responses.</p></div><div class="css-pr87ee e12etsbl0"><pre><code class="language-javascript">app.use(&quot;/hi&quot;, function(req, res) {
  res.send(&quot;Hey!&quot;);
})</code></pre></div><div class="section css-2fdgsn" id="client-side-routes"><h3 class="displaced-header"><a class="header-link" href="#client-side-routes">Client-Side Routes</a></h3><div class="css-cv69qk e12etsbl1"><p>Instead of telling the server about every single valid client-side route, a wildcard path is used to match every request. Determining what to render for the request will be done by a Curi router, which we will create in the wildcard&#x27;s handler function.</p></div><div class="css-pr87ee e12etsbl0"><pre><code class="language-javascript">// the wildcard matches every GET request
app.get(&quot;*&quot;, renderHandler);</code></pre></div><div class="css-cv69qk e12etsbl1"><div class="css-mezw60 e1bjkffy0"><strong>Note:</strong> <!-- -->The <code class="inline-code language-javascript css-14f7g1f eutm4hs0">*</code> wildcard handler is similar to the Curi path<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">(.*)</code>. Express and Curi both use<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">path-to-regexp</code> for path matching. However, Express uses an old version. <code class="inline-code language-javascript css-14f7g1f eutm4hs0">path-to-regexp</code> removed support for the barebones <code class="inline-code language-javascript css-14f7g1f eutm4hs0">*</code> pattern in the version that Curi uses, which is why we have to use <code class="inline-code language-javascript css-14f7g1f eutm4hs0">(.*)</code> in Curi routes.</div></div></div><div class="section css-2fdgsn" id="static-assets"><h3 class="displaced-header"><a class="header-link" href="#static-assets">Static Assets</a></h3><div class="css-cv69qk e12etsbl1"><p>Page requests aren&#x27;t the only requests that the framework will handle. Requests for static resources, like scripts, stylesheet, and images shouldn&#x27;t be handled by Curi. Express provides a<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">static()</code> method to map request locations &quot;real&quot; (files exist on the server) locations.</p></div><div class="css-pr87ee e12etsbl0"><pre><code class="language-javascript">app.use(&quot;/static&quot;, express.static());</code></pre></div><div class="css-cv69qk e12etsbl1"><p>Using the above static file handler, all static file requests in HTML/JavaScript should begin with <code class="inline-code language-javascript css-14f7g1f eutm4hs0">/static</code>.</p></div><div class="css-pr87ee e12etsbl0"><pre><code class="language-html">&lt;img src=&quot;/static/img/circle.png&quot; /&gt;</code></pre></div></div><div class="section css-2fdgsn" id="path-order"><h3 class="displaced-header"><a class="header-link" href="#path-order">Path Order</a></h3><div class="css-cv69qk e12etsbl1"><p>Express matches against paths in the order that they are registered, so the static files path needs to be defined before the wildcard path.</p><p>Any other non-page paths, like APIs, would also need to be defined before the catch-all.</p></div><div class="css-pr87ee e12etsbl0"><pre><code class="language-javascript">app.use(&quot;/static&quot;, express.static());
app.use(&quot;/api&quot;, dataHandler);
app.get(&quot;*&quot;, renderHandler);</code></pre></div></div></div><div class="section css-2fdgsn" id="handler"><h2 class="displaced-header"><a class="header-link" href="#handler">Render Handler</a></h2><div class="css-cv69qk e12etsbl1"><p>The render handler function receives the request object and a response object. The response object is used to build and send a response to the user.</p></div><div class="css-pr87ee e12etsbl0"><pre><code class="language-javascript">// renderer.js
export default function renderHandler(req, res) {

}

// server.js
const renderHandler = require(&quot;./renderer&quot;);

app.get(&quot;*&quot;, renderHandler)</code></pre></div><div class="css-mezw60 e1bjkffy0"><strong>Note:</strong> <!-- -->If you are setting up a server without server-side rendering, the<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">renderHandler</code> function could use <code class="inline-code language-javascript css-14f7g1f eutm4hs0">res.sendFile()</code> <!-- -->to return a universal HTML file for every route.</div><div class="css-pr87ee e12etsbl0"><pre><code class="language-javascript">const index = path.join(__dirname, &quot;public&quot;, &quot;index.html&quot;);
          
export default function renderHandler(req, res) {
  res.sendFile(index);
}</code></pre></div></div><div class="section css-2fdgsn" id="router"><h2 class="displaced-header"><a class="header-link" href="#router">Router</a></h2><div class="css-cv69qk e12etsbl1"><p>A router instance will be created for every single request. This is a big reason why we wrap the routes array in a<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">prepareRoutes</code> call. Without <code class="inline-code language-javascript css-14f7g1f eutm4hs0">prepareRoutes</code>, the route pathes would need to be re-compiled for every request!</p><p>The router will match the requested location to its routes and generate a response. Once the response is generated, the handler can render the application.</p></div><div class="css-pr87ee e12etsbl0"><pre><code class="language-javascript">// renderer.js
function handler(req, res) {
  const router = curi(history, routes);
  router.once(({ response }) =&gt; {
    // render the response
  })
}</code></pre></div><div class="css-cv69qk e12etsbl1"><p>Where do the history and routes come from?</p></div><div class="section css-2fdgsn" id="history"><h3 class="displaced-header"><a class="header-link" href="#history">History</a></h3><div class="css-cv69qk e12etsbl1"><p>On the client-side, a single-page application uses<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">@hickory/browser</code> to create a history instance. However, that uses browser only APIs. On the server, the<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">@hickory/in-memory</code> package is used to create an equivalent history instance.</p></div><div class="css-pr87ee e12etsbl0"><pre><code class="language-bash">npm install @hickory/in-memory</code></pre></div><div class="css-cv69qk e12etsbl1">An in-memory history takes an array of locations. For server-side rendering, we want to pass it the location from the request.</div><div class="css-pr87ee e12etsbl0"><pre><code class="language-javascript">// handler.js
import InMemory from &quot;@hickory/in-memory&quot;;

function handler(req, res) {
  const history = InMemory({ locations: [req.path] });
  const router = curi(history, routes);
  // ...
}</code></pre></div></div><div class="section css-2fdgsn" id="routes"><h3 class="displaced-header"><a class="header-link" href="#routes">Routes</a></h3><div class="css-cv69qk e12etsbl1"><p>Ideally, you will be able to re-use your client side routes on the server, but if the client routes use browser only APIs, you may need to adapt the routes to work on the server.</p></div><div class="css-pr87ee e12etsbl0"><pre><code class="language-javascript">// handler.js
import routes from &quot;../client/routes&quot;;</code></pre></div><div class="css-cv69qk e12etsbl1"><p>One approach to client/server routes is to keep two copies: one for the client and one for the server. However, this should be a last resort because it can lead to inconsistencies if you update one file but not the other.</p><p>A more reusable approach would be to use &quot;universal&quot; wrappers around any environment specific APIs. For example, the<!-- --> <a href="https://github.com/matthew-andrews/isomorphic-fetch"><code class="inline-code language-javascript css-14f7g1f eutm4hs0">isomorphic-fetch</code></a> <!-- -->package could be used to support <code class="inline-code language-javascript css-14f7g1f eutm4hs0">fetch()</code> in the browser and Node.</p></div><div class="css-pr87ee e12etsbl0"><pre><code class="language-javascript">// routes.js
import fetch from &quot;isomorphic-fetch&quot;;
import { prepareRoutes } from &quot;@curi/router&quot;;

export default prepareRoutes([
  {
    name: &quot;Test&quot;,
    path: &quot;test&quot;,
    resolve: {
      data: () =&gt; fetch(&quot;/test-data&quot;)
    }
  }
]);</code></pre></div></div><div class="section css-2fdgsn" id="automatic-redirects"><h3 class="displaced-header"><a class="header-link" href="#automatic-redirects">Automatic Redirects</a></h3><div class="css-cv69qk e12etsbl1"><p>Curi automatically redirects to a new location when a response with a <code class="inline-code language-javascript css-14f7g1f eutm4hs0">redirectTo</code> property is generated. On the client, this is convenient because it saves you from having to detect the redirect and manually redirecting yourself. However, on the server it can cause issues.</p><p>The issue happens because when Curi automatically redirects, another response is created for the location that Curi redirects to. If this response is ready before you try to render the current response, you&#x27;ll render the redirected location&#x27;s response instead of the initial response.</p><p>Curi&#x27;s <code class="inline-code language-javascript css-14f7g1f eutm4hs0">automaticRedirects</code> option lets you disable automatic redirects when its value is <code class="inline-code language-javascript css-14f7g1f eutm4hs0">false</code>. This lets you be certain that you are rendering using the initial response.</p></div><div class="css-pr87ee e12etsbl0"><pre data-line="3-5"><code class="language-javascript">function renderHandler(req, res) {
  const history = InMemory({ locations: [req.path] });
  const router = curi(history, routes, {
    automaticRedirects: false
  });
}</code></pre></div></div></div><div class="section css-2fdgsn" id="handling-response"><h2 class="displaced-header"><a class="header-link" href="#handling-response">Handling the Response</a></h2><div class="css-cv69qk e12etsbl1"><p>When the router is created, it will start generating a response by matching its <code class="inline-code language-javascript css-14f7g1f eutm4hs0">history</code> object&#x27;s current location. If the application has any asynchronous routes, the <code class="inline-code language-javascript css-14f7g1f eutm4hs0">response</code> may not be ready immediately. The safest approach is to use<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">router.once</code> to wait for the <code class="inline-code language-javascript css-14f7g1f eutm4hs0">response</code>.</p></div><div class="css-pr87ee e12etsbl0"><pre data-line="6-8"><code class="language-javascript">function renderHandler(req, res) {
  const history = InMemory({ locations: [req.path] });
  const router = curi(history, routes, {
    automaticRedirects: false
  });
  router.once(({ response }) =&gt; {
    // ...
  });
}</code></pre></div><div class="css-cv69qk e12etsbl1"><p>The next step is to render the application to generate an HTML response string that will be sent to the user. How exactly you do this depends on what UI renderer you are using, but the process is approximately the same for most renderering libraries.</p><p>Here, we will assume that you are using React. The<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">react-dom</code> package (through its <code class="inline-code language-javascript css-14f7g1f eutm4hs0">server</code> module), provides a <code class="inline-code language-javascript css-14f7g1f eutm4hs0">renderToString</code> method, which will render an application as a string.</p><p>Rendering with React on the server is essentially the same as rendering on the client. We create a <code class="inline-code language-jsx css-14f7g1f eutm4hs0">&lt;<!-- -->Router<!-- -->&gt;</code> and use<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">renderToString</code> (instead of <code class="inline-code language-javascript css-14f7g1f eutm4hs0">ReactDOM.render</code>) to render the component, passing it a render-invoked function.</p></div><div class="css-pr87ee e12etsbl0"><pre data-line="1-2,10-18"><code class="language-javascript">import { renderToString } from &quot;react-dom/server&quot;;
import { curiProvider } from &quot;@curi/react-dom&quot;;
         
function renderHandler(req, res) {
  const history = InMemory({ locations: [req.path] });
  const router = curi(history, routes, {
    automaticRedirects: false
  });
  router.once(({ response }) =&gt; {
    const Router = curiProvider(router);
    const markup = renderToString(
      &lt;Router&gt;
        {({ response }) =&gt; {
          const { body:Body } = response;
          return &lt;Body response={response} /&gt;;
        }}
      &lt;/Router&gt;
    );
  });
}</code></pre></div><div class="css-cv69qk e12etsbl1"><p>Rendering with <code class="inline-code language-javascript css-14f7g1f eutm4hs0">renderToString</code> only generates an HTML string for the application. We are missing the <code class="inline-code language-jsx css-14f7g1f eutm4hs0">&lt;<!-- -->html<!-- -->&gt;</code>,<!-- --> <code class="inline-code language-jsx css-14f7g1f eutm4hs0">&lt;<!-- -->head<!-- -->&gt;</code>,<code class="inline-code language-jsx css-14f7g1f eutm4hs0">&lt;<!-- -->body<!-- -->&gt;</code>, <code class="inline-code language-jsx css-14f7g1f eutm4hs0">&lt;<!-- -->script<!-- -->&gt;</code>, etc. tags that are required for the full HTML page.</p><p>We can write a function that takes the string created by<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">renderToString</code>and inserts it into the full HTML string for a page.</p><p>For a React application, the markup string should be set as the child of its container element. If you render into the<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">#root</code> element on the client, the HTML should have a<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">#root</code> element.</p><p>Any JavaScript scripts that need to be rendered should also be included in the HTML. Make sure that their paths are absolute; if the path is relative, then you will run into errors resolving the location for nested routes!</p><p>If your routes set <code class="inline-code language-javascript css-14f7g1f eutm4hs0">title</code> strings on the<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">response</code>, you can also pass that value to the markup insertion function and set the title in the HTML string.</p></div><div class="css-pr87ee e12etsbl0"><pre data-line="4-15,32-33"><code class="language-javascript">import { renderToString } from &quot;react-dom/server&quot;;
import { curiProvider } from &quot;@curi/react-dom&quot;;

function insertMarkup(markup, title) {
  return `&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;${title} | My Site&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;${markup}&lt;/div&gt;
    &lt;script src=&quot;/static/js/bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;`;
}

function renderHandler(req, res) {
  const history = InMemory({ locations: [req.path] });
  const router = curi(history, routes, {
    automaticRedirects: false
  });
  router.once(({ response }) =&gt; {
    const Router = curiProvider(router);
    const markup = renderToString(
      &lt;Router&gt;
        {({ response }) =&gt; {
          const { body:Body } = response;
          return &lt;Body response={response} /&gt;;
        }}
      &lt;/Router&gt;
    );
    const html = insertMarkup(markup, response.title);
    res.send(html);
  });
}</code></pre></div><div class="css-cv69qk e12etsbl1"><div class="css-mezw60 e1bjkffy0"><strong>Note:</strong> <!-- -->If you server render a React application, you should use<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">ReactDOM.hydrate</code> instead of <code class="inline-code language-javascript css-14f7g1f eutm4hs0">ReactDOM.render</code> on the client.</div></div><div class="section css-2fdgsn" id="redirect-responses"><h3 class="displaced-header"><a class="header-link" href="#redirect-responses">Redirect Responses</a></h3><div class="css-cv69qk e12etsbl1"><p>If a route matches and it redirects, you can handle it without rendering the application. A <code class="inline-code language-javascript css-14f7g1f eutm4hs0">response</code> is a redirect if it has a <code class="inline-code language-javascript css-14f7g1f eutm4hs0">redirectTo</code> property. <code class="inline-code language-javascript css-14f7g1f eutm4hs0">redirectTo.url</code> <!-- -->is that full URL (<code class="inline-code language-javascript css-14f7g1f eutm4hs0">pathname</code>, <code class="inline-code language-javascript css-14f7g1f eutm4hs0">query</code>, and<!-- --> <code class="inline-code language-javascript css-14f7g1f eutm4hs0">hash</code>).</p></div><div class="css-pr87ee e12etsbl0"><pre data-line="10-13"><code class="language-javascript">import { renderToString } from &quot;react-dom/server&quot;;
import { curiProvider } from &quot;@curi/react-dom&quot;;

function renderHandler(req, res) {
  const history = InMemory({ locations: [req.path] });
  const router = curi(history, routes, {
    automaticRedirects: false
  });
  router.once(({ response }) =&gt; {
    if (response.redirectTo) {
      res.redirect(301);
      return;
    }
    // otherwise, render
  });
}</code></pre></div></div></div></div></div></main></div>
    <script src="https://unpkg.com/react@16.6.3/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@16.6.3/umd/react-dom.production.min.js"></script>
    <script src="/static/js/prism.js"></script>
    <script src="/static/js/bundle.js"></script>
  </body>
</html>
